<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="pdoc 7.1.1" />
    <title>go_utils.lc API documentation</title>
    <link rel="" type="" href=""/>

    <script>
    /*
    MathJax by default does not define $ as a math delimiter because it's commonly used in non-mathematical settings.
    We add it here for demonstration purposes. If you stick to \( and/or $$, you can remove this block.
    */
    window.MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      }
    };
    </script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

<style>/*! * Bootstrap Reboot v5.0.0 (https://getbootstrap.com/) * Copyright 2011-2021 The Bootstrap Authors * Copyright 2011-2021 Twitter, Inc. * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE) * Forked from Normalize.css, licensed MIT (https://github.com/necolas/normalize.css/blob/master/LICENSE.md) */*,::after,::before{box-sizing:border-box}@media (prefers-reduced-motion:no-preference){:root{scroll-behavior:smooth}}body{margin:0;font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans","Liberation Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";font-size:1rem;font-weight:400;line-height:1.5;color:#212529;background-color:#fff;-webkit-text-size-adjust:100%;-webkit-tap-highlight-color:transparent}hr{margin:1rem 0;color:inherit;background-color:currentColor;border:0;opacity:.25}hr:not([size]){height:1px}h1,h2,h3,h4,h5,h6{margin-top:0;margin-bottom:.5rem;font-weight:500;line-height:1.2}h1{font-size:calc(1.375rem + 1.5vw)}@media (min-width:1200px){h1{font-size:2.5rem}}h2{font-size:calc(1.325rem + .9vw)}@media (min-width:1200px){h2{font-size:2rem}}h3{font-size:calc(1.3rem + .6vw)}@media (min-width:1200px){h3{font-size:1.75rem}}h4{font-size:calc(1.275rem + .3vw)}@media (min-width:1200px){h4{font-size:1.5rem}}h5{font-size:1.25rem}h6{font-size:1rem}p{margin-top:0;margin-bottom:1rem}abbr[data-bs-original-title],abbr[title]{-webkit-text-decoration:underline dotted;text-decoration:underline dotted;cursor:help;-webkit-text-decoration-skip-ink:none;text-decoration-skip-ink:none}address{margin-bottom:1rem;font-style:normal;line-height:inherit}ol,ul{padding-left:2rem}dl,ol,ul{margin-top:0;margin-bottom:1rem}ol ol,ol ul,ul ol,ul ul{margin-bottom:0}dt{font-weight:700}dd{margin-bottom:.5rem;margin-left:0}blockquote{margin:0 0 1rem}b,strong{font-weight:bolder}small{font-size:.875em}mark{padding:.2em;background-color:#fcf8e3}sub,sup{position:relative;font-size:.75em;line-height:0;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}a{color:#0d6efd;text-decoration:underline}a:hover{color:#0a58ca}a:not([href]):not([class]),a:not([href]):not([class]):hover{color:inherit;text-decoration:none}code,kbd,pre,samp{font-family:SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;font-size:1em;direction:ltr;unicode-bidi:bidi-override}pre{display:block;margin-top:0;margin-bottom:1rem;overflow:auto;font-size:.875em}pre code{font-size:inherit;color:inherit;word-break:normal}code{font-size:.875em;color:#d63384;word-wrap:break-word}a>code{color:inherit}kbd{padding:.2rem .4rem;font-size:.875em;color:#fff;background-color:#212529;border-radius:.2rem}kbd kbd{padding:0;font-size:1em;font-weight:700}figure{margin:0 0 1rem}img,svg{vertical-align:middle}table{caption-side:bottom;border-collapse:collapse}caption{padding-top:.5rem;padding-bottom:.5rem;color:#6c757d;text-align:left}th{text-align:inherit;text-align:-webkit-match-parent}tbody,td,tfoot,th,thead,tr{border-color:inherit;border-style:solid;border-width:0}label{display:inline-block}button{border-radius:0}button:focus:not(:focus-visible){outline:0}button,input,optgroup,select,textarea{margin:0;font-family:inherit;font-size:inherit;line-height:inherit}button,select{text-transform:none}[role=button]{cursor:pointer}select{word-wrap:normal}select:disabled{opacity:1}[list]::-webkit-calendar-picker-indicator{display:none}[type=button],[type=reset],[type=submit],button{-webkit-appearance:button}[type=button]:not(:disabled),[type=reset]:not(:disabled),[type=submit]:not(:disabled),button:not(:disabled){cursor:pointer}::-moz-focus-inner{padding:0;border-style:none}textarea{resize:vertical}fieldset{min-width:0;padding:0;margin:0;border:0}legend{float:left;width:100%;padding:0;margin-bottom:.5rem;font-size:calc(1.275rem + .3vw);line-height:inherit}@media (min-width:1200px){legend{font-size:1.5rem}}legend+*{clear:left}::-webkit-datetime-edit-day-field,::-webkit-datetime-edit-fields-wrapper,::-webkit-datetime-edit-hour-field,::-webkit-datetime-edit-minute,::-webkit-datetime-edit-month-field,::-webkit-datetime-edit-text,::-webkit-datetime-edit-year-field{padding:0}::-webkit-inner-spin-button{height:auto}[type=search]{outline-offset:-2px;-webkit-appearance:textfield}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-color-swatch-wrapper{padding:0}::file-selector-button{font:inherit}::-webkit-file-upload-button{font:inherit;-webkit-appearance:button}output{display:inline-block}iframe{border:0}summary{display:list-item;cursor:pointer}progress{vertical-align:baseline}[hidden]{display:none!important}</style>
<style>/*! pygments syntax highlighting */pre{line-height:125%;}td.linenos pre{color:#000000; background-color:#f0f0f0; padding-left:5px; padding-right:5px;}span.linenos{color:#000000; background-color:#f0f0f0; padding-left:5px; padding-right:5px;}td.linenos pre.special{color:#000000; background-color:#ffffc0; padding-left:5px; padding-right:5px;}span.linenos.special{color:#000000; background-color:#ffffc0; padding-left:5px; padding-right:5px;}.pdoc .hll{background-color:#ffffcc}.pdoc{background:#f8f8f8;}.pdoc .c{color:#408080; font-style:italic}.pdoc .err{border:1px solid #FF0000}.pdoc .k{color:#008000; font-weight:bold}.pdoc .o{color:#666666}.pdoc .ch{color:#408080; font-style:italic}.pdoc .cm{color:#408080; font-style:italic}.pdoc .cp{color:#BC7A00}.pdoc .cpf{color:#408080; font-style:italic}.pdoc .c1{color:#408080; font-style:italic}.pdoc .cs{color:#408080; font-style:italic}.pdoc .gd{color:#A00000}.pdoc .ge{font-style:italic}.pdoc .gr{color:#FF0000}.pdoc .gh{color:#000080; font-weight:bold}.pdoc .gi{color:#00A000}.pdoc .go{color:#888888}.pdoc .gp{color:#000080; font-weight:bold}.pdoc .gs{font-weight:bold}.pdoc .gu{color:#800080; font-weight:bold}.pdoc .gt{color:#0044DD}.pdoc .kc{color:#008000; font-weight:bold}.pdoc .kd{color:#008000; font-weight:bold}.pdoc .kn{color:#008000; font-weight:bold}.pdoc .kp{color:#008000}.pdoc .kr{color:#008000; font-weight:bold}.pdoc .kt{color:#B00040}.pdoc .m{color:#666666}.pdoc .s{color:#BA2121}.pdoc .na{color:#7D9029}.pdoc .nb{color:#008000}.pdoc .nc{color:#0000FF; font-weight:bold}.pdoc .no{color:#880000}.pdoc .nd{color:#AA22FF}.pdoc .ni{color:#999999; font-weight:bold}.pdoc .ne{color:#D2413A; font-weight:bold}.pdoc .nf{color:#0000FF}.pdoc .nl{color:#A0A000}.pdoc .nn{color:#0000FF; font-weight:bold}.pdoc .nt{color:#008000; font-weight:bold}.pdoc .nv{color:#19177C}.pdoc .ow{color:#AA22FF; font-weight:bold}.pdoc .w{color:#bbbbbb}.pdoc .mb{color:#666666}.pdoc .mf{color:#666666}.pdoc .mh{color:#666666}.pdoc .mi{color:#666666}.pdoc .mo{color:#666666}.pdoc .sa{color:#BA2121}.pdoc .sb{color:#BA2121}.pdoc .sc{color:#BA2121}.pdoc .dl{color:#BA2121}.pdoc .sd{color:#BA2121; font-style:italic}.pdoc .s2{color:#BA2121}.pdoc .se{color:#BB6622; font-weight:bold}.pdoc .sh{color:#BA2121}.pdoc .si{color:#BB6688; font-weight:bold}.pdoc .sx{color:#008000}.pdoc .sr{color:#BB6688}.pdoc .s1{color:#BA2121}.pdoc .ss{color:#19177C}.pdoc .bp{color:#008000}.pdoc .fm{color:#0000FF}.pdoc .vc{color:#19177C}.pdoc .vg{color:#19177C}.pdoc .vi{color:#19177C}.pdoc .vm{color:#19177C}.pdoc .il{color:#666666}</style>
<style>/*! pdoc */:root{--pdoc-background:#fff;}.pdoc{--text:#212529;--muted:#6c757d;--link:#3660a5;--link-hover:#1659c5;--code:#f7f7f7;--active:#fff598;--accent:#eee;--accent2:#c1c1c1;--nav-hover:rgba(255, 255, 255, 0.5);--name:#0066BB;--def:#008800;--annotation:#007020;}body{background-color:var(--pdoc-background);}html, body{width:100%;height:100%;}@media (max-width:769px){#navtoggle{cursor:pointer;position:absolute;width:50px;height:40px;top:1rem;right:1rem;border-color:var(--text);color:var(--text);display:flex;opacity:0.8;}#navtoggle:hover{opacity:1;}#togglestate + div{display:none;}#togglestate:checked + div{display:inherit;}main, header{padding:2rem 3vw;}.git-button{display:none !important;}nav input[type="search"]:valid ~ *{display:none !important;}}@media (min-width:770px){:root{--sidebar-width:clamp(12.5rem, 28vw, 22rem);}nav{position:fixed;overflow:auto;height:100vh;width:var(--sidebar-width);}main, header{padding:3rem 2rem 3rem calc(var(--sidebar-width) + 3rem);width:calc(54rem + var(--sidebar-width));max-width:100%;}#navtoggle{display:none;}}#togglestate{display:none;}nav.pdoc{--pad:1.75rem;--indent:1.5rem;background-color:var(--accent);border-right:1px solid var(--accent2);box-shadow:0 0 20px rgba(50, 50, 50, .2) inset;padding:0 0 0 var(--pad);overflow-wrap:anywhere;scrollbar-width:thin; scrollbar-color:var(--accent2) transparent }nav.pdoc::-webkit-scrollbar{width:.4rem; }nav.pdoc::-webkit-scrollbar-thumb{background-color:var(--accent2); }nav.pdoc > div{padding:var(--pad) 0;}nav.pdoc .module-list-button{display:inline-flex;align-items:center;color:var(--text);border-color:var(--muted);margin-bottom:1rem;}nav.pdoc .module-list-button:hover{border-color:var(--text);}nav.pdoc input[type=search]{display:block;outline-offset:0;width:calc(100% - var(--pad));}nav.pdoc ul{list-style:none;padding-left:0;}nav.pdoc li{display:block;margin:0;padding:.2rem 0 .2rem var(--indent);transition:all 100ms;}nav.pdoc > div > ul > li{padding-left:0;}nav.pdoc li:hover{background-color:var(--nav-hover);}nav.pdoc a, nav.pdoc a:hover{color:var(--text);}nav.pdoc a{display:block;}nav.pdoc > h2:first-of-type{margin-top:1.5rem;}nav.pdoc .class:before{content:"class ";color:var(--muted);}nav.pdoc .function:after{content:"()";color:var(--muted);}html, main{scroll-behavior:smooth;}.pdoc{color:var(--text);box-sizing:border-box;line-height:1.5;background:none;}.pdoc .pdoc-button{display:inline-block;border:solid black 1px;border-radius:2px;font-size:.75rem;padding:calc(0.5em - 1px) 1em;transition:100ms all;}.pdoc .visually-hidden{position:absolute !important;width:1px !important;height:1px !important;padding:0 !important;margin:-1px !important;overflow:hidden !important;clip:rect(0, 0, 0, 0) !important;white-space:nowrap !important;border:0 !important;}.pdoc h1, .pdoc h2, .pdoc h3{font-weight:300;margin:.3em 0;padding:.2em 0;}.pdoc a{text-decoration:none;color:var(--link);}.pdoc a:hover{color:var(--link-hover);}.pdoc blockquote{margin-left:2rem;}.pdoc pre{background-color:var(--code);border-top:1px solid var(--accent2);border-bottom:1px solid var(--accent2);margin-bottom:1em;padding:.5rem 0 .5rem .5rem;overflow-x:auto;}.pdoc code{color:var(--text);padding:.2em .4em;margin:0;font-size:85%;background-color:var(--code);border-radius:6px;}.pdoc a > code{color:inherit;}.pdoc pre > code{display:inline-block;font-size:inherit;background:none;border:none;padding:0;}.pdoc .modulename{margin-top:0;font-weight:bold;}.pdoc .modulename a{color:var(--link);transition:100ms all;}.pdoc .git-button{float:right;border:solid var(--link) 1px;}.pdoc .git-button:hover{background-color:var(--link);color:var(--pdoc-background);}.pdoc details{--shift:-40px;text-align:right;margin-top:var(--shift);margin-bottom:calc(0px - var(--shift));clear:both;filter:opacity(1);}.pdoc details:not([open]){height:0;overflow:visible;}.pdoc details > summary{font-size:.75rem;cursor:pointer;color:var(--muted);border-width:0;padding:0 .7em;display:inline-block;display:inline list-item;user-select:none;}.pdoc details > summary:focus{outline:0;}.pdoc details > div{margin-top:calc(0px - var(--shift) / 2);text-align:left;}.pdoc .docstring{margin-bottom:1.5rem;}.pdoc > section:first-of-type > .docstring{margin-bottom:3rem;}.pdoc .docstring pre{margin-left:1em;margin-right:1em;}.pdoc h1:target,.pdoc h2:target,.pdoc h3:target,.pdoc h4:target,.pdoc h5:target,.pdoc h6:target{background-color:var(--active);box-shadow:-1rem 0 0 0 var(--active);}.pdoc div:target > .attr,.pdoc section:target > .attr,.pdoc dd:target > a{background-color:var(--active);}.pdoc .attr:hover{filter:contrast(0.95);}.pdoc .headerlink{position:absolute;width:0;margin-left:-1.5rem;line-height:1.4rem;font-size:1.5rem;font-weight:normal;transition:all 100ms ease-in-out;opacity:0;}.pdoc .attr > .headerlink{margin-left:-2.5rem;}.pdoc *:hover > .headerlink,.pdoc *:target > .attr > .headerlink{opacity:1;}.pdoc .attr{display:block;color:var(--text);margin:1rem 0 .5rem;padding:.4rem 5rem .4rem 1rem;background-color:var(--accent);}.pdoc .classattr{margin-left:2rem;}.pdoc .name{color:var(--name);font-weight:bold;}.pdoc .def{color:var(--def);font-weight:bold;}.pdoc .signature{white-space:pre-wrap;}.pdoc .annotation{color:var(--annotation);}.pdoc .inherited{margin-left:2rem;}.pdoc .inherited dt{font-weight:700;}.pdoc .inherited dt, .pdoc .inherited dd{display:inline;margin-left:0;margin-bottom:.5rem;}.pdoc .inherited dd:not(:last-child):after{content:", ";}.pdoc .inherited .class:before{content:"class ";}.pdoc .inherited .function a:after{content:"()";}.pdoc .search-result .docstring{overflow:auto;max-height:25vh;}.pdoc .search-result.focused > .attr{background-color:var(--active);}.pdoc .attribution{margin-top:2rem;display:block;opacity:0.5;transition:all 200ms;filter:grayscale(100%);}.pdoc .attribution:hover{opacity:1;filter:grayscale(0%);}.pdoc .attribution img{margin-left:5px;height:35px;vertical-align:middle;width:70px;transition:all 200ms;}</style>
</head>
<body>        <nav class="pdoc">
            <label id="navtoggle" for="togglestate" class="pdoc-button"><svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 30 30'><path stroke-linecap='round' stroke="currentColor" stroke-miterlimit='10' stroke-width='2' d='M4 7h22M4 15h22M4 23h22'/></svg></label>
            <input id="togglestate" type="checkbox">
            <div>
                        <a class="pdoc-button module-list-button" href="../go_utils.html">
<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-box-arrow-in-left" viewBox="0 0 16 16">
  <path fill-rule="evenodd" d="M10 3.5a.5.5 0 0 0-.5-.5h-8a.5.5 0 0 0-.5.5v9a.5.5 0 0 0 .5.5h8a.5.5 0 0 0 .5-.5v-2a.5.5 0 0 1 1 0v2A1.5 1.5 0 0 1 9.5 14h-8A1.5 1.5 0 0 1 0 12.5v-9A1.5 1.5 0 0 1 1.5 2h8A1.5 1.5 0 0 1 11 3.5v2a.5.5 0 0 1-1 0v-2z"/>
  <path fill-rule="evenodd" d="M4.146 8.354a.5.5 0 0 1 0-.708l3-3a.5.5 0 1 1 .708.708L5.707 7.5H14.5a.5.5 0 0 1 0 1H5.707l2.147 2.146a.5.5 0 0 1-.708.708l-3-3z"/>
</svg>                            &nbsp;go_utils</a>

                        <input type="search" placeholder="Search..." role="searchbox" aria-label="search"
                               pattern=".+" required>

<img src="https://strategies.org/wp-content/uploads/2020/03/IGES-RevLogo-Dec2019-150rgb-Sml.png" style="display: block; margin: 1em auto">

                    <h2>Contents</h2>
                    <ul>
  <li><a href="#unpacking-the-landcover-classification-data">Unpacking the Landcover Classification Data</a></li>
</ul>



                    <h2>API Documentation</h2>
                        <ul class="memberlist">
            <li>
                    <a class="function" href="#cleanup_column_prefix">cleanup_column_prefix</a>
            </li>
            <li>
                    <a class="function" href="#extract_classification_name">extract_classification_name</a>
            </li>
            <li>
                    <a class="function" href="#extract_classification_percentage">extract_classification_percentage</a>
            </li>
            <li>
                    <a class="function" href="#extract_classifications">extract_classifications</a>
            </li>
            <li>
                    <a class="function" href="#extract_percentages">extract_percentages</a>
            </li>
            <li>
                    <a class="function" href="#extract_classification_dict">extract_classification_dict</a>
            </li>
            <li>
                    <a class="function" href="#unpack_classifications">unpack_classifications</a>
            </li>
            <li>
                    <a class="function" href="#photo_bit_flags">photo_bit_flags</a>
            </li>
            <li>
                    <a class="function" href="#classification_bit_flags">classification_bit_flags</a>
            </li>
            <li>
                    <a class="function" href="#completion_scores">completion_scores</a>
            </li>
            <li>
                    <a class="function" href="#apply_cleanup">apply_cleanup</a>
            </li>
            <li>
                    <a class="function" href="#add_flags">add_flags</a>
            </li>
            <li>
                    <a class="function" href="#direction_frequency">direction_frequency</a>
            </li>
            <li>
                    <a class="function" href="#diagnostic_plots">diagnostic_plots</a>
            </li>
            <li>
                    <a class="function" href="#qa_filter">qa_filter</a>
            </li>
            <li>
                    <a class="function" href="#get_main_classifications">get_main_classifications</a>
            </li>
    </ul>


                    <a class="attribution" title="pdoc: Python API documentation generator" href="https://pdoc.dev">
                        built with <span class="visually-hidden">pdoc</span><img
                            alt="pdoc logo"
                            src="data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20role%3D%22img%22%20aria-label%3D%22pdoc%20logo%22%20width%3D%22300%22%20height%3D%22150%22%20viewBox%3D%22-1%200%2060%2030%22%3E%3Ctitle%3Epdoc%3C/title%3E%3Cpath%20d%3D%22M29.621%2021.293c-.011-.273-.214-.475-.511-.481a.5.5%200%200%200-.489.503l-.044%201.393c-.097.551-.695%201.215-1.566%201.704-.577.428-1.306.486-2.193.182-1.426-.617-2.467-1.654-3.304-2.487l-.173-.172a3.43%203.43%200%200%200-.365-.306.49.49%200%200%200-.286-.196c-1.718-1.06-4.931-1.47-7.353.191l-.219.15c-1.707%201.187-3.413%202.131-4.328%201.03-.02-.027-.49-.685-.141-1.763.233-.721.546-2.408.772-4.076.042-.09.067-.187.046-.288.166-1.347.277-2.625.241-3.351%201.378-1.008%202.271-2.586%202.271-4.362%200-.976-.272-1.935-.788-2.774-.057-.094-.122-.18-.184-.268.033-.167.052-.339.052-.516%200-1.477-1.202-2.679-2.679-2.679-.791%200-1.496.352-1.987.9a6.3%206.3%200%200%200-1.001.029c-.492-.564-1.207-.929-2.012-.929-1.477%200-2.679%201.202-2.679%202.679A2.65%202.65%200%200%200%20.97%206.554c-.383.747-.595%201.572-.595%202.41%200%202.311%201.507%204.29%203.635%205.107-.037.699-.147%202.27-.423%203.294l-.137.461c-.622%202.042-2.515%208.257%201.727%2010.643%201.614.908%203.06%201.248%204.317%201.248%202.665%200%204.492-1.524%205.322-2.401%201.476-1.559%202.886-1.854%206.491.82%201.877%201.393%203.514%201.753%204.861%201.068%202.223-1.713%202.811-3.867%203.399-6.374.077-.846.056-1.469.054-1.537zm-4.835%204.313c-.054.305-.156.586-.242.629-.034-.007-.131-.022-.307-.157-.145-.111-.314-.478-.456-.908.221.121.432.25.675.355.115.039.219.051.33.081zm-2.251-1.238c-.05.33-.158.648-.252.694-.022.001-.125-.018-.307-.157-.217-.166-.488-.906-.639-1.573.358.344.754.693%201.198%201.036zm-3.887-2.337c-.006-.116-.018-.231-.041-.342.635.145%201.189.368%201.599.625.097.231.166.481.174.642-.03.049-.055.101-.067.158-.046.013-.128.026-.298.004-.278-.037-.901-.57-1.367-1.087zm-1.127-.497c.116.306.176.625.12.71-.019.014-.117.045-.345.016-.206-.027-.604-.332-.986-.695.41-.051.816-.056%201.211-.031zm-4.535%201.535c.209.22.379.47.358.598-.006.041-.088.138-.351.234-.144.055-.539-.063-.979-.259a11.66%2011.66%200%200%200%20.972-.573zm.983-.664c.359-.237.738-.418%201.126-.554.25.237.479.548.457.694-.006.042-.087.138-.351.235-.174.064-.694-.105-1.232-.375zm-3.381%201.794c-.022.145-.061.29-.149.401-.133.166-.358.248-.69.251h-.002c-.133%200-.306-.26-.45-.621.417.091.854.07%201.291-.031zm-2.066-8.077a4.78%204.78%200%200%201-.775-.584c.172-.115.505-.254.88-.378l-.105.962zm-.331%202.302a10.32%2010.32%200%200%201-.828-.502c.202-.143.576-.328.984-.49l-.156.992zm-.45%202.157l-.701-.403c.214-.115.536-.249.891-.376a11.57%2011.57%200%200%201-.19.779zm-.181%201.716c.064.398.194.702.298.893-.194-.051-.435-.162-.736-.398.061-.119.224-.3.438-.495zM8.87%204.141c0%20.152-.123.276-.276.276s-.275-.124-.275-.276.123-.276.276-.276.275.124.275.276zm-.735-.389a1.15%201.15%200%200%200-.314.783%201.16%201.16%200%200%200%201.162%201.162c.457%200%20.842-.27%201.032-.653.026.117.042.238.042.362a1.68%201.68%200%200%201-1.679%201.679%201.68%201.68%200%200%201-1.679-1.679c0-.843.626-1.535%201.436-1.654zM5.059%205.406A1.68%201.68%200%200%201%203.38%207.085a1.68%201.68%200%200%201-1.679-1.679c0-.037.009-.072.011-.109.21.3.541.508.935.508a1.16%201.16%200%200%200%201.162-1.162%201.14%201.14%200%200%200-.474-.912c.015%200%20.03-.005.045-.005.926.001%201.679.754%201.679%201.68zM3.198%204.141c0%20.152-.123.276-.276.276s-.275-.124-.275-.276.123-.276.276-.276.275.124.275.276zM1.375%208.964c0-.52.103-1.035.288-1.52.466.394%201.06.64%201.717.64%201.144%200%202.116-.725%202.499-1.738.383%201.012%201.355%201.738%202.499%201.738.867%200%201.631-.421%202.121-1.062.307.605.478%201.267.478%201.942%200%202.486-2.153%204.51-4.801%204.51s-4.801-2.023-4.801-4.51zm24.342%2019.349c-.985.498-2.267.168-3.813-.979-3.073-2.281-5.453-3.199-7.813-.705-1.315%201.391-4.163%203.365-8.423.97-3.174-1.786-2.239-6.266-1.261-9.479l.146-.492c.276-1.02.395-2.457.444-3.268a6.11%206.11%200%200%200%201.18.115%206.01%206.01%200%200%200%202.536-.562l-.006.175c-.802.215-1.848.612-2.021%201.25-.079.295.021.601.274.837.219.203.415.364.598.501-.667.304-1.243.698-1.311%201.179-.02.144-.022.507.393.787.213.144.395.26.564.365-1.285.521-1.361.96-1.381%201.126-.018.142-.011.496.427.746l.854.489c-.473.389-.971.914-.999%201.429-.018.278.095.532.316.713.675.556%201.231.721%201.653.721.059%200%20.104-.014.158-.02.207.707.641%201.64%201.513%201.64h.013c.8-.008%201.236-.345%201.462-.626.173-.216.268-.457.325-.692.424.195.93.374%201.372.374.151%200%20.294-.021.423-.068.732-.27.944-.704.993-1.021.009-.061.003-.119.002-.179.266.086.538.147.789.147.15%200%20.294-.021.423-.069.542-.2.797-.489.914-.754.237.147.478.258.704.288.106.014.205.021.296.021.356%200%20.595-.101.767-.229.438.435%201.094.992%201.656%201.067.106.014.205.021.296.021a1.56%201.56%200%200%200%20.323-.035c.17.575.453%201.289.866%201.605.358.273.665.362.914.362a.99.99%200%200%200%20.421-.093%201.03%201.03%200%200%200%20.245-.164c.168.428.39.846.68%201.068.358.273.665.362.913.362a.99.99%200%200%200%20.421-.093c.317-.148.512-.448.639-.762.251.157.495.257.726.257.127%200%20.25-.024.37-.071.427-.17.706-.617.841-1.314.022-.015.047-.022.068-.038.067-.051.133-.104.196-.159-.443%201.486-1.107%202.761-2.086%203.257zM8.66%209.925a.5.5%200%201%200-1%200c0%20.653-.818%201.205-1.787%201.205s-1.787-.552-1.787-1.205a.5.5%200%201%200-1%200c0%201.216%201.25%202.205%202.787%202.205s2.787-.989%202.787-2.205zm4.4%2015.965l-.208.097c-2.661%201.258-4.708%201.436-6.086.527-1.542-1.017-1.88-3.19-1.844-4.198a.4.4%200%200%200-.385-.414c-.242-.029-.406.164-.414.385-.046%201.249.367%203.686%202.202%204.896.708.467%201.547.7%202.51.7%201.248%200%202.706-.392%204.362-1.174l.185-.086a.4.4%200%200%200%20.205-.527c-.089-.204-.326-.291-.527-.206zM9.547%202.292c.093.077.205.114.317.114a.5.5%200%200%200%20.318-.886L8.817.397a.5.5%200%200%200-.703.068.5.5%200%200%200%20.069.703l1.364%201.124zm-7.661-.065c.086%200%20.173-.022.253-.068l1.523-.893a.5.5%200%200%200-.506-.863l-1.523.892a.5.5%200%200%200-.179.685c.094.158.261.247.432.247z%22%20transform%3D%22matrix%28-1%200%200%201%2058%200%29%22%20fill%3D%22%233bb300%22/%3E%3Cpath%20d%3D%22M.3%2021.86V10.18q0-.46.02-.68.04-.22.18-.5.28-.54%201.34-.54%201.06%200%201.42.28.38.26.44.78.76-1.04%202.38-1.04%201.64%200%203.1%201.54%201.46%201.54%201.46%203.58%200%202.04-1.46%203.58-1.44%201.54-3.08%201.54-1.64%200-2.38-.92v4.04q0%20.46-.04.68-.02.22-.18.5-.14.3-.5.42-.36.12-.98.12-.62%200-1-.12-.36-.12-.52-.4-.14-.28-.18-.5-.02-.22-.02-.68zm3.96-9.42q-.46.54-.46%201.18%200%20.64.46%201.18.48.52%201.2.52.74%200%201.24-.52.52-.52.52-1.18%200-.66-.48-1.18-.48-.54-1.26-.54-.76%200-1.22.54zm14.741-8.36q.16-.3.54-.42.38-.12%201-.12.64%200%201.02.12.38.12.52.42.16.3.18.54.04.22.04.68v11.94q0%20.46-.04.7-.02.22-.18.5-.3.54-1.7.54-1.38%200-1.54-.98-.84.96-2.34.96-1.8%200-3.28-1.56-1.48-1.58-1.48-3.66%200-2.1%201.48-3.68%201.5-1.58%203.28-1.58%201.48%200%202.3%201v-4.2q0-.46.02-.68.04-.24.18-.52zm-3.24%2010.86q.52.54%201.26.54.74%200%201.22-.54.5-.54.5-1.18%200-.66-.48-1.22-.46-.56-1.26-.56-.8%200-1.28.56-.48.54-.48%201.2%200%20.66.52%201.2zm7.833-1.2q0-2.4%201.68-3.96%201.68-1.56%203.84-1.56%202.16%200%203.82%201.56%201.66%201.54%201.66%203.94%200%201.66-.86%202.96-.86%201.28-2.1%201.9-1.22.6-2.54.6-1.32%200-2.56-.64-1.24-.66-2.1-1.92-.84-1.28-.84-2.88zm4.18%201.44q.64.48%201.3.48.66%200%201.32-.5.66-.5.66-1.48%200-.98-.62-1.46-.62-.48-1.34-.48-.72%200-1.34.5-.62.5-.62%201.48%200%20.96.64%201.46zm11.412-1.44q0%20.84.56%201.32.56.46%201.18.46.64%200%201.18-.36.56-.38.9-.38.6%200%201.46%201.06.46.58.46%201.04%200%20.76-1.1%201.42-1.14.8-2.8.8-1.86%200-3.58-1.34-.82-.64-1.34-1.7-.52-1.08-.52-2.36%200-1.3.52-2.34.52-1.06%201.34-1.7%201.66-1.32%203.54-1.32.76%200%201.48.22.72.2%201.06.4l.32.2q.36.24.56.38.52.4.52.92%200%20.5-.42%201.14-.72%201.1-1.38%201.1-.38%200-1.08-.44-.36-.34-1.04-.34-.66%200-1.24.48-.58.48-.58%201.34z%22%20fill%3D%22green%22/%3E%3C/svg%3E"/>
                    </a>
            </div>
        </nav>
    <main class="pdoc">
            <section>
                    <h1 class="modulename">
<a href="./../go_utils.html">go_utils</a><wbr>.lc    </h1>

                        <div class="docstring"><h2 id="unpacking-the-landcover-classification-data">Unpacking the Landcover Classification Data</h2>

<p>The classification data for each entry is condensed into several entries separated by a semicolon. <a href="#unpack_classifications">This method</a> identifies and parses Land Cover Classifications and percentages to create new columns. The columns are also reordered to better group directional information together.</p>

<p>The end result is a DataFrame that contains columns for every Unique Landcover Classification (per direction) and its respective percentages for each entry.</p>

<p>There are four main steps to this procedure:
1.Identifying Land Cover Classifications for each Cardinal Direction: An internal method returns the unique description (e.g. HerbaceousGrasslandTallGrass) listed in a column. This method is run for all 4 cardinal directions to obtain the all unique classifications per direction.</p>

<ol>
<li>Creating empty columns for each Classification from each Cardinal Direction: Using the newly identified classifications new columns are made for each unique classification. These columns initially contained the default float64 value of 0.0. By initializing all the classification column values to 0.0, we ensure no empty values are set to -9999 in the round_cols(df) method (discussed in General Cleanup Procedures - Round Appropriate Columns). This step eases future numerical analysis.</li>
<li>Grouping and Alphabetically Sorting Directional Column Information: To better organize the DataFrame, columns containing any of the following directional substrings: "downward", "upward", "west", "east", "north", "south" (case insensitive) are identified and alphabetically sorted. Then an internal method called move_cols, specified column headers to move (direction_data_cols), and the location before the desired point of insertion, the program returns a reordered DataFrame, where all directional columns are grouped together. This greatly improves the Land Covers dataset’s organization and accessibility.</li>
<li>Adding Classification Percentages to their respective Land Cover Classification Columns - To fill in each classification column with their respective percentages, an internal method is applied to each row in the dataframe. This method iterates through each classification direction (ie “lc_EastClassifications”) and sets each identified Classification column with its respective percentage.</li>
</ol>

<p>NOTE: After these procedures, the original directional classification columns (e.g. “lc_EastClassifications”) are not dropped.</p>
</div>

                        <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span>

<span class="kn">from</span> <span class="nn">go_utils.cleanup</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">replace_column_prefix</span><span class="p">,</span>
    <span class="n">rename_latlon_cols</span><span class="p">,</span>
    <span class="n">standardize_null_vals</span><span class="p">,</span>
    <span class="n">round_cols</span><span class="p">,</span>
    <span class="n">camel_case</span><span class="p">,</span>
    <span class="n">remove_homogenous_cols</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">go_utils.plot</span> <span class="kn">import</span> <span class="n">completeness_histogram</span><span class="p">,</span> <span class="n">plot_freq_bar</span><span class="p">,</span> <span class="n">multiple_bar_graph</span>


<span class="vm">__doc__</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>

<span class="s2">## Unpacking the Landcover Classification Data</span>
<span class="s2">The classification data for each entry is condensed into several entries separated by a semicolon. [This method](#unpack_classifications) identifies and parses Land Cover Classifications and percentages to create new columns. The columns are also reordered to better group directional information together.</span>

<span class="s2">The end result is a DataFrame that contains columns for every Unique Landcover Classification (per direction) and its respective percentages for each entry.</span>

<span class="s2">There are four main steps to this procedure:</span>
<span class="s2">1.Identifying Land Cover Classifications for each Cardinal Direction: An internal method returns the unique description (e.g. HerbaceousGrasslandTallGrass) listed in a column. This method is run for all 4 cardinal directions to obtain the all unique classifications per direction.</span>
<span class="s2">2. Creating empty columns for each Classification from each Cardinal Direction: Using the newly identified classifications new columns are made for each unique classification. These columns initially contained the default float64 value of 0.0. By initializing all the classification column values to 0.0, we ensure no empty values are set to -9999 in the round_cols(df) method (discussed in General Cleanup Procedures - Round Appropriate Columns). This step eases future numerical analysis.</span>
<span class="s2">3. Grouping and Alphabetically Sorting Directional Column Information: To better organize the DataFrame, columns containing any of the following directional substrings: &quot;downward&quot;, &quot;upward&quot;, &quot;west&quot;, &quot;east&quot;, &quot;north&quot;, &quot;south&quot; (case insensitive) are identified and alphabetically sorted. Then an internal method called move_cols, specified column headers to move (direction_data_cols), and the location before the desired point of insertion, the program returns a reordered DataFrame, where all directional columns are grouped together. This greatly improves the Land Covers dataset’s organization and accessibility.</span>
<span class="s2">4. Adding Classification Percentages to their respective Land Cover Classification Columns - To fill in each classification column with their respective percentages, an internal method is applied to each row in the dataframe. This method iterates through each classification direction (ie “lc_EastClassifications”) and sets each identified Classification column with its respective percentage.</span>

<span class="s2">NOTE: After these procedures, the original directional classification columns (e.g. “lc_EastClassifications”) are not dropped.</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="n">classifications</span> <span class="o">=</span> <span class="p">[]</span>


<span class="k">def</span> <span class="nf">cleanup_column_prefix</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Method for shortening raw landcover column names.</span>

<span class="sd">    The df object will now replace the verbose `landcovers` prefix in some of the columns with `lc_`</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    df : pd.DataFrame</span>
<span class="sd">        The DataFrame containing raw landcover data. The DataFrame object itself will be modified.</span>
<span class="sd">    inplace : bool, default=False</span>
<span class="sd">        Whether to return a new DataFrame. If True then no DataFrame copy is not returned and the operation is performed in place.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pd.DataFrame or None</span>
<span class="sd">        A DataFrame with the cleaned up column prefixes. If `inplace=True` it returns None.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">replace_column_prefix</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="s2">&quot;landcovers&quot;</span><span class="p">,</span> <span class="s2">&quot;lc&quot;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">df</span>


<span class="k">def</span> <span class="nf">extract_classification_name</span><span class="p">(</span><span class="n">entry</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extracts the name (landcover description) of a singular landcover classification. For example in the classification of `&quot;60% MUC 02 (b) [Trees, Closely Spaced, Deciduous - Broad Leaved]&quot;`, the `&quot;Trees, Closely Spaced, Deciduous - Broad Leaved&quot;` is extracted.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    entry : str</span>
<span class="sd">        A single landcover classification.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    str</span>
<span class="sd">        The Landcover description of a classification</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(?&lt;=\[).*(?=\])&quot;</span><span class="p">,</span> <span class="n">entry</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">extract_classification_percentage</span><span class="p">(</span><span class="n">entry</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extracts the percentage of a singular landcover classification. For example in the classification of `&quot;60% MUC 02 (b) [Trees, Closely Spaced, Deciduous - Broad Leaved]&quot;`, the `60` is extracted.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    entry : str</span>
<span class="sd">        A single landcover classification.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float</span>
<span class="sd">        The percentage of a landcover classification</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s2">&quot;.*(?=%)&quot;</span><span class="p">,</span> <span class="n">entry</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">())</span>


<span class="k">def</span> <span class="nf">_extract_landcover_items</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">info</span><span class="p">):</span>
    <span class="n">entries</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;;&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">func</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span> <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">entries</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">extract_classifications</span><span class="p">(</span><span class="n">info</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Extracts the name/landcover description (see [here](#extract_classification_name) for a clearer definition) of a landcover classification entry in the GLOBE Observer Data.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    info : str</span>
<span class="sd">        A string representing a landcover classification entry in the GLOBE Observer Datset.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list of str</span>
<span class="sd">        The different landcover classifications stored within the landcover entry.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_extract_landcover_items</span><span class="p">(</span><span class="n">extract_classification_name</span><span class="p">,</span> <span class="n">info</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">extract_percentages</span><span class="p">(</span><span class="n">info</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Extracts the percentages (see [here](#extract_classification_percentage) for a clearer definition) of a landcover classification in the GLOBE Observer Datset.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    info : str</span>
<span class="sd">        A string representing a landcover classification entry in the GLOBE Observer Datset.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list of float</span>
<span class="sd">        The different landcover percentages stored within the landcover entry.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">_extract_landcover_items</span><span class="p">(</span><span class="n">extract_classification_percentage</span><span class="p">,</span> <span class="n">info</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">extract_classification_dict</span><span class="p">(</span><span class="n">info</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Extracts the landcover descriptions and percentages of a landcover classification entry as a dictionary.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    info : str</span>
<span class="sd">        A string representing a landcover classification entry in the GLOBE Observer Datset.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict of str, float</span>
<span class="sd">        The landcover descriptions and percentages stored as a dict in the form: `{&quot;description&quot; : percentage}`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">entries</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;;&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="n">extract_classification_name</span><span class="p">(</span><span class="n">entry</span><span class="p">):</span> <span class="n">extract_classification_percentage</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">entries</span>
    <span class="p">}</span>


<span class="k">def</span> <span class="nf">_get_classifications_for_direction</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">direction_col_name</span><span class="p">):</span>
    <span class="n">list_of_land_types</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">info</span> <span class="ow">in</span> <span class="n">df</span><span class="p">[</span><span class="n">direction_col_name</span><span class="p">]:</span>
        <span class="c1"># Note: Sometimes info = np.nan, a float -- In that case we do NOT parse/split</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">info</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
            <span class="p">[</span>
                <span class="n">list_of_land_types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">camel_case</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="s2">&quot;,&quot;</span><span class="p">,</span> <span class="s2">&quot;-&quot;</span><span class="p">,</span> <span class="s2">&quot;/&quot;</span><span class="p">]))</span>
                <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">extract_classifications</span><span class="p">(</span><span class="n">info</span><span class="p">)</span>
            <span class="p">]</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">list_of_land_types</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">_move_cols</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">cols_to_move</span><span class="o">=</span><span class="p">[],</span> <span class="n">ref_col</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
    <span class="n">col_names</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="n">index_before_desired_loc</span> <span class="o">=</span> <span class="n">col_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">ref_col</span><span class="p">)</span>

    <span class="n">cols_before_index</span> <span class="o">=</span> <span class="n">col_names</span><span class="p">[:</span> <span class="n">index_before_desired_loc</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">cols_at_index</span> <span class="o">=</span> <span class="n">cols_to_move</span>

    <span class="n">cols_before_index</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">cols_before_index</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cols_at_index</span><span class="p">]</span>
    <span class="n">cols_after_index</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">col_names</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cols_before_index</span> <span class="o">+</span> <span class="n">cols_at_index</span>
    <span class="p">]</span>

    <span class="k">return</span> <span class="n">df</span><span class="p">[</span><span class="n">cols_before_index</span> <span class="o">+</span> <span class="n">cols_at_index</span> <span class="o">+</span> <span class="n">cols_after_index</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">unpack_classifications</span><span class="p">(</span>
    <span class="n">lc_df</span><span class="p">,</span>
    <span class="n">north</span><span class="o">=</span><span class="s2">&quot;lc_NorthClassifications&quot;</span><span class="p">,</span>
    <span class="n">east</span><span class="o">=</span><span class="s2">&quot;lc_EastClassifications&quot;</span><span class="p">,</span>
    <span class="n">south</span><span class="o">=</span><span class="s2">&quot;lc_SouthClassifications&quot;</span><span class="p">,</span>
    <span class="n">west</span><span class="o">=</span><span class="s2">&quot;lc_WestClassifications&quot;</span><span class="p">,</span>
    <span class="n">ref_col</span><span class="o">=</span><span class="s2">&quot;lc_pid&quot;</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Unpacks the classification data in the *raw* GLOBE Observer Landcover data. This method assumes that the columns have been renamed with accordance to the [column cleanup](#cleanup_column_prefix) method.</span>

<span class="sd">    This returns a copy of the dataframe.</span>

<span class="sd">    See [here](#unpacking-the-landcover-classification-data) for more information.</span>

<span class="sd">    *Note:* The returned DataFrame will have around 250 columns.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lc_df : pd.DataFrame</span>
<span class="sd">        A DataFrame containing Raw GLOBE Observer Landcover data that has had the column names simplified.</span>
<span class="sd">    north: str, default=&quot;lc_NorthClassifications&quot;</span>
<span class="sd">        The name of the column which contains the North Classifications</span>
<span class="sd">    east: str, default=&quot;lc_EastClassifications&quot;</span>
<span class="sd">        The name of the column which contains the East Classifications</span>
<span class="sd">    south: str, default=&quot;lc_SouthClassifications&quot;</span>
<span class="sd">        The name of the column which contains the South Classifications</span>
<span class="sd">    west: str, default=&quot;lc_WestClassifications&quot;</span>
<span class="sd">        The name of the column which contains the West Classifications</span>
<span class="sd">    west: str, default=&quot;lc_pid&quot;</span>
<span class="sd">        The name of the column which all of the expanded values will be placed after. For example, if the columns were `[1, 2, 3, 4]` and you chose 3, the new columns will now be `[1, 2, 3, (all classification columns), 4]`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pd.DataFrame</span>
<span class="sd">        A DataFrame with the unpacked classification columns.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">classifications</span> <span class="o">=</span> <span class="p">[</span><span class="n">north</span><span class="p">,</span> <span class="n">east</span><span class="p">,</span> <span class="n">south</span><span class="p">,</span> <span class="n">west</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">set_directions</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">classification</span> <span class="ow">in</span> <span class="n">classifications</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">classification</span><span class="p">]):</span>
                <span class="n">entries</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">classification</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;;&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">entries</span><span class="p">:</span>
                    <span class="n">percent</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">extract_classification_percentage</span><span class="p">(</span><span class="n">entry</span><span class="p">),</span>
                        <span class="n">extract_classification_name</span><span class="p">(</span><span class="n">entry</span><span class="p">),</span>
                    <span class="p">)</span>
                    <span class="n">name</span> <span class="o">=</span> <span class="n">camel_case</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="s2">&quot;,&quot;</span><span class="p">,</span> <span class="s2">&quot;-&quot;</span><span class="p">,</span> <span class="s2">&quot;/&quot;</span><span class="p">])</span>
                    <span class="n">classification</span> <span class="o">=</span> <span class="n">classification</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;Classifications&quot;</span><span class="p">,</span> <span class="s2">&quot;_&quot;</span><span class="p">)</span>
                    <span class="n">overall</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span>
                        <span class="sa">r</span><span class="s2">&quot;(north|south|east|west).*&quot;</span><span class="p">,</span>
                        <span class="s2">&quot;Overall_&quot;</span><span class="p">,</span>
                        <span class="n">key</span><span class="p">,</span>
                        <span class="n">flags</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">row</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">classification</span><span class="si">}{</span><span class="n">name</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">percent</span>
                    <span class="n">row</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">overall</span><span class="si">}{</span><span class="n">name</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="n">percent</span>
        <span class="k">return</span> <span class="n">row</span>

    <span class="n">land_type_columns_to_add</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">classification</span><span class="p">:</span> <span class="n">_get_classifications_for_direction</span><span class="p">(</span><span class="n">lc_df</span><span class="p">,</span> <span class="n">classification</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">classification</span> <span class="ow">in</span> <span class="n">classifications</span>
    <span class="p">}</span>
    <span class="n">overall_columns</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">values</span> <span class="ow">in</span> <span class="n">land_type_columns_to_add</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">direction_name</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;Classifications&quot;</span><span class="p">,</span> <span class="s2">&quot;_&quot;</span><span class="p">)</span>
        <span class="n">overall</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span>
            <span class="sa">r</span><span class="s2">&quot;(north|south|east|west).*&quot;</span><span class="p">,</span> <span class="s2">&quot;Overall_&quot;</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">values</span><span class="p">:</span>
            <span class="n">lc_df</span><span class="p">[</span><span class="n">direction_name</span> <span class="o">+</span> <span class="n">value</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">lc_df</span><span class="p">[</span><span class="n">overall</span> <span class="o">+</span> <span class="n">value</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">overall_columns</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">overall</span> <span class="o">+</span> <span class="n">value</span><span class="p">)</span>
    <span class="n">direction_data_cols</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="n">name</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">lc_df</span><span class="o">.</span><span class="n">columns</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span>
                <span class="n">direction</span> <span class="ow">in</span> <span class="n">name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">direction</span> <span class="ow">in</span> <span class="p">(</span>
                    <span class="s2">&quot;downward&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;upward&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;west&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;east&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;north&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;south&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;overall&quot;</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="p">]</span>
    <span class="p">)</span>
    <span class="n">lc_df</span> <span class="o">=</span> <span class="n">_move_cols</span><span class="p">(</span><span class="n">lc_df</span><span class="p">,</span> <span class="n">cols_to_move</span><span class="o">=</span><span class="n">direction_data_cols</span><span class="p">,</span> <span class="n">ref_col</span><span class="o">=</span><span class="n">ref_col</span><span class="p">)</span>
    <span class="n">lc_df</span> <span class="o">=</span> <span class="n">lc_df</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">set_directions</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">overall_columns</span><span class="p">:</span>
        <span class="n">lc_df</span><span class="p">[</span><span class="n">column</span><span class="p">]</span> <span class="o">/=</span> <span class="mi">4</span>
    <span class="k">return</span> <span class="n">lc_df</span>


<span class="k">def</span> <span class="nf">photo_bit_flags</span><span class="p">(</span>
    <span class="n">df</span><span class="p">,</span>
    <span class="n">up</span><span class="o">=</span><span class="s2">&quot;lc_UpwardPhotoUrl&quot;</span><span class="p">,</span>
    <span class="n">down</span><span class="o">=</span><span class="s2">&quot;lc_DownwardPhotoUrl&quot;</span><span class="p">,</span>
    <span class="n">north</span><span class="o">=</span><span class="s2">&quot;lc_NorthPhotoUrl&quot;</span><span class="p">,</span>
    <span class="n">south</span><span class="o">=</span><span class="s2">&quot;lc_SouthPhotoUrl&quot;</span><span class="p">,</span>
    <span class="n">east</span><span class="o">=</span><span class="s2">&quot;lc_EastPhotoUrl&quot;</span><span class="p">,</span>
    <span class="n">west</span><span class="o">=</span><span class="s2">&quot;lc_WestPhotoUrl&quot;</span><span class="p">,</span>
    <span class="n">photo_count</span><span class="o">=</span><span class="s2">&quot;lc_PhotoCount&quot;</span><span class="p">,</span>
    <span class="n">rejected_count</span><span class="o">=</span><span class="s2">&quot;lc_RejectedCount&quot;</span><span class="p">,</span>
    <span class="n">pending_count</span><span class="o">=</span><span class="s2">&quot;lc_PendingCount&quot;</span><span class="p">,</span>
    <span class="n">empty_count</span><span class="o">=</span><span class="s2">&quot;lc_EmptyCount&quot;</span><span class="p">,</span>
    <span class="n">bit_binary</span><span class="o">=</span><span class="s2">&quot;lc_PhotoBitBinary&quot;</span><span class="p">,</span>
    <span class="n">bit_decimal</span><span class="o">=</span><span class="s2">&quot;lc_PhotoBitDecimal&quot;</span><span class="p">,</span>
    <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates the following flags:</span>
<span class="sd">    - `PhotoCount`: The number of valid photos per record.</span>
<span class="sd">    - `RejectedCount`: The number of photos that were rejected per record.</span>
<span class="sd">    - `PendingCount`: The number of photos that are pending approval per record.</span>
<span class="sd">    - `PhotoBitBinary`: A string that represents the presence of a photo in the Up, Down, North, South, East, and West directions. For example, if the entry is `110100`, that indicates that there is a valid photo for the Up, Down, and South Directions but no valid photos for the North, East, and West Directions.</span>
<span class="sd">    - `PhotoBitDecimal`: The numerical representation of the lc_PhotoBitBinary string.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    df : pd.DataFrame</span>
<span class="sd">        A land cover DataFrame</span>
<span class="sd">    up : str, default=&quot;lc_UpwardPhotoUrl&quot;</span>
<span class="sd">        The name of the column in the land cover DataFrame that contains the url for the upwards photo.</span>
<span class="sd">    down : str, default=&quot;lc_DownwardPhotoUrl&quot;</span>
<span class="sd">        The name of the column in the land cover DataFrame that contains the url for the downwards photo.</span>
<span class="sd">    north : str, default=&quot;lc_NorthPhotoUrl&quot;</span>
<span class="sd">        The name of the column in the land cover DataFrame that contains the url for the north photo.</span>
<span class="sd">    south : str, default=&quot;lc_SouthPhotoUrl&quot;</span>
<span class="sd">        The name of the column in the land cover DataFrame that contains the url for the south photo.</span>
<span class="sd">    east : str, default=&quot;lc_EastPhotoUrl&quot;</span>
<span class="sd">        The name of the column in the land cover DataFrame that contains the url for the east photo.</span>
<span class="sd">    west : str, default=&quot;lc_WestPhotoUrl&quot;</span>
<span class="sd">        The name of the column in the land cover DataFrame that contains the url for the west photo.</span>
<span class="sd">    photo_count : str, default=&quot;lc_PhotoCount&quot;</span>
<span class="sd">        The name of the column that will be storing the PhotoCount flag.</span>
<span class="sd">    rejected_count : str, default=&quot;lc_RejectedCount&quot;</span>
<span class="sd">        The name of the column that will be storing the RejectedCount flag.</span>
<span class="sd">    pending_count : str, default=&quot;lc_PendingCount&quot;</span>
<span class="sd">        The name of the column that will be storing the PendingCount flag.</span>
<span class="sd">    empty_count : str, default=&quot;lc_EmptyCount&quot;</span>
<span class="sd">        The name of the column that will be storing the EmptyCount flag.</span>
<span class="sd">    bit_binary : str, default=&quot;lc_PhotoBitBinary&quot;</span>
<span class="sd">        The name of the column that will be storing the PhotoBitBinary flag.</span>
<span class="sd">    bit_decimal : str, default=&quot;lc_PhotoBitDecimal&quot;</span>
<span class="sd">        The name of the column that will be storing the PhotoBitDecimal flag.</span>
<span class="sd">    inplace : bool, default=False</span>
<span class="sd">        Whether to return a new DataFrame. If True then no DataFrame copy is not returned and the operation is performed in place.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pd.DataFrame or None</span>
<span class="sd">        A DataFrame with the photo bit flags. If `inplace=True` it returns None.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">pic_data</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="n">pic_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">rejected_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">pending_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">empty_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">valid_photo_bit_mask</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

        <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">pd</span><span class="o">.</span><span class="n">isna</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span> <span class="ow">and</span> <span class="s2">&quot;http&quot;</span> <span class="ow">in</span> <span class="n">entry</span><span class="p">:</span>
                <span class="n">valid_photo_bit_mask</span> <span class="o">+=</span> <span class="s2">&quot;1&quot;</span>
                <span class="n">pic_count</span> <span class="o">+=</span> <span class="n">entry</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s2">&quot;http&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">valid_photo_bit_mask</span> <span class="o">+=</span> <span class="s2">&quot;0&quot;</span>
            <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">isna</span><span class="p">(</span><span class="n">entry</span><span class="p">):</span>
                <span class="n">empty_count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pending_count</span> <span class="o">+=</span> <span class="n">entry</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s2">&quot;pending&quot;</span><span class="p">)</span>
                <span class="n">rejected_count</span> <span class="o">+=</span> <span class="n">entry</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s2">&quot;rejected&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">pic_count</span><span class="p">,</span>
            <span class="n">rejected_count</span><span class="p">,</span>
            <span class="n">pending_count</span><span class="p">,</span>
            <span class="n">empty_count</span><span class="p">,</span>
            <span class="n">valid_photo_bit_mask</span><span class="p">,</span>
            <span class="nb">int</span><span class="p">(</span><span class="n">valid_photo_bit_mask</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">get_photo_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">pic_data</span><span class="p">)</span>
    <span class="p">(</span>
        <span class="n">df</span><span class="p">[</span><span class="n">photo_count</span><span class="p">],</span>
        <span class="n">df</span><span class="p">[</span><span class="n">rejected_count</span><span class="p">],</span>
        <span class="n">df</span><span class="p">[</span><span class="n">pending_count</span><span class="p">],</span>
        <span class="n">df</span><span class="p">[</span><span class="n">empty_count</span><span class="p">],</span>
        <span class="n">df</span><span class="p">[</span><span class="n">bit_binary</span><span class="p">],</span>
        <span class="n">df</span><span class="p">[</span><span class="n">bit_decimal</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">=</span> <span class="n">get_photo_data</span><span class="p">(</span>
        <span class="n">df</span><span class="p">[</span><span class="n">up</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(),</span>
        <span class="n">df</span><span class="p">[</span><span class="n">down</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(),</span>
        <span class="n">df</span><span class="p">[</span><span class="n">north</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(),</span>
        <span class="n">df</span><span class="p">[</span><span class="n">south</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(),</span>
        <span class="n">df</span><span class="p">[</span><span class="n">east</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(),</span>
        <span class="n">df</span><span class="p">[</span><span class="n">west</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(),</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">df</span>


<span class="k">def</span> <span class="nf">classification_bit_flags</span><span class="p">(</span>
    <span class="n">df</span><span class="p">,</span>
    <span class="n">north</span><span class="o">=</span><span class="s2">&quot;lc_NorthClassifications&quot;</span><span class="p">,</span>
    <span class="n">south</span><span class="o">=</span><span class="s2">&quot;lc_SouthClassifications&quot;</span><span class="p">,</span>
    <span class="n">east</span><span class="o">=</span><span class="s2">&quot;lc_EastClassifications&quot;</span><span class="p">,</span>
    <span class="n">west</span><span class="o">=</span><span class="s2">&quot;lc_WestClassifications&quot;</span><span class="p">,</span>
    <span class="n">classification_count</span><span class="o">=</span><span class="s2">&quot;lc_ClassificationCount&quot;</span><span class="p">,</span>
    <span class="n">bit_binary</span><span class="o">=</span><span class="s2">&quot;lc_ClassificationBitBinary&quot;</span><span class="p">,</span>
    <span class="n">bit_decimal</span><span class="o">=</span><span class="s2">&quot;lc_ClassificationBitDecimal&quot;</span><span class="p">,</span>
    <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates the following flags:</span>
<span class="sd">    - `ClassificationCount`: The number of classifications per record.</span>
<span class="sd">    - `BitBinary`: A string that represents the presence of a classification in the North, South, East, and West directions. For example, if the entry is `1101`, that indicates that there is a valid classification for the North, South, and West Directions but no valid classifications for the East Direction.</span>
<span class="sd">    - `BitDecimal`: The number of photos that are pending approval per record.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    df : pd.DataFrame</span>
<span class="sd">        A land cover DataFrame</span>
<span class="sd">    north : str, default=&quot;lc_NorthClassifications&quot;</span>
<span class="sd">        The name of the column in the land cover DataFrame that contains the north classification.</span>
<span class="sd">    south : str, default=&quot;lc_SouthClassifications&quot;</span>
<span class="sd">        The name of the column in the land cover DataFrame that contains the south classification.</span>
<span class="sd">    east : str, default=&quot;lc_EastClassifications&quot;</span>
<span class="sd">        The name of the column in the land cover DataFrame that contains the east classification.</span>
<span class="sd">    west : str, default=&quot;lc_WestClassifications&quot;</span>
<span class="sd">        The name of the column in the land cover DataFrame that contains the west classification.</span>
<span class="sd">    classification_count : str, default=&quot;lc_ClassificationCount&quot;</span>
<span class="sd">        The name of the column that will store the ClassificationCount flag.</span>
<span class="sd">    bit_binary : str, default=&quot;lc_ClassificationBitBinary&quot;</span>
<span class="sd">        The name of the column that will store the BitBinary flag.</span>
<span class="sd">    bit_decimal : str, default=&quot;lc_ClassificationBitDecimal&quot;</span>
<span class="sd">        The name of the column that will store the BitDecimal flag.</span>
<span class="sd">    inplace : bool, default=False</span>
<span class="sd">        Whether to return a new DataFrame. If True then no DataFrame copy is not returned and the operation is performed in place.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pd.DataFrame or None</span>
<span class="sd">        A DataFrame with the classification bit flags. If `inplace=True` it returns None.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">classification_data</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="n">classification_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">classification_bit_mask</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">isna</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span> <span class="ow">or</span> <span class="n">entry</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">:</span>
                <span class="n">classification_bit_mask</span> <span class="o">+=</span> <span class="s2">&quot;0&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">classification_count</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">classification_bit_mask</span> <span class="o">+=</span> <span class="s2">&quot;1&quot;</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">classification_count</span><span class="p">,</span>
            <span class="n">classification_bit_mask</span><span class="p">,</span>
            <span class="nb">int</span><span class="p">(</span><span class="n">classification_bit_mask</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">get_classification_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">classification_data</span><span class="p">)</span>

    <span class="p">(</span>
        <span class="n">df</span><span class="p">[</span><span class="n">classification_count</span><span class="p">],</span>
        <span class="n">df</span><span class="p">[</span><span class="n">bit_binary</span><span class="p">],</span>
        <span class="n">df</span><span class="p">[</span><span class="n">bit_decimal</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">=</span> <span class="n">get_classification_data</span><span class="p">(</span>
        <span class="n">df</span><span class="p">[</span><span class="n">north</span><span class="p">],</span>
        <span class="n">df</span><span class="p">[</span><span class="n">south</span><span class="p">],</span>
        <span class="n">df</span><span class="p">[</span><span class="n">east</span><span class="p">],</span>
        <span class="n">df</span><span class="p">[</span><span class="n">west</span><span class="p">],</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">df</span>


<span class="k">def</span> <span class="nf">completion_scores</span><span class="p">(</span>
    <span class="n">df</span><span class="p">,</span>
    <span class="n">photo_bit_binary</span><span class="o">=</span><span class="s2">&quot;lc_PhotoBitBinary&quot;</span><span class="p">,</span>
    <span class="n">classification_binary</span><span class="o">=</span><span class="s2">&quot;lc_ClassificationBitBinary&quot;</span><span class="p">,</span>
    <span class="n">sub_completeness</span><span class="o">=</span><span class="s2">&quot;lc_SubCompletenessScore&quot;</span><span class="p">,</span>
    <span class="n">completeness</span><span class="o">=</span><span class="s2">&quot;lc_CumulativeCompletenessScore&quot;</span><span class="p">,</span>
    <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Adds the following completness score flags:</span>
<span class="sd">    - `SubCompletenessScore`: The percentage of valid landcover classifications and photos that are filled out.</span>
<span class="sd">    - `CumulativeCompletenessScore`: The percentage of non null values out of all the columns.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    df : pd.DataFrame</span>
<span class="sd">        A landcover DataFrame with the [`PhotoBitBinary`](#photo_bit_flags) and [`ClassificationBitBinary`](#classification_bit_flags) flags.</span>
<span class="sd">    photo_bit_binary : str, default=&quot;lc_PhotoBitBinary&quot;</span>
<span class="sd">        The name of the column that stores the PhotoBitBinary flag.</span>
<span class="sd">    classification_binary : str, default=&quot;lc_PhotoBitBinary&quot;</span>
<span class="sd">        The name of the column that stores the ClassificationBitBinary flag.</span>
<span class="sd">    sub_completeness : str, default=&quot;lc_PhotoBitBinary&quot;</span>
<span class="sd">        The name of the column that will store the generated SubCompletenessScore flag.</span>
<span class="sd">    completeness : str, default=&quot;lc_PhotoBitBinary&quot;</span>
<span class="sd">        The name of the column that will store the generated CompletenessScore flag.</span>
<span class="sd">    inplace : bool, default=False</span>
<span class="sd">        Whether to return a new DataFrame. If True then no DataFrame copy is not returned and the operation is performed in place.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pd.DataFrame or None</span>
<span class="sd">        A DataFrame with the completeness score flags. If `inplace=True` it returns None.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">sum_bit_mask</span><span class="p">(</span><span class="n">bit_mask</span><span class="o">=</span><span class="s2">&quot;0&quot;</span><span class="p">):</span>
        <span class="nb">sum</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">bit_mask</span><span class="p">:</span>
            <span class="nb">sum</span> <span class="o">+=</span> <span class="nb">int</span><span class="p">(</span><span class="n">char</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">sum</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">scores</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">scores</span><span class="p">[</span><span class="s2">&quot;sub_score&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># Cummulative Completion Score</span>
    <span class="n">scores</span><span class="p">[</span><span class="s2">&quot;cumulative_score&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
    <span class="c1"># Sub-Score</span>
    <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>
        <span class="n">bit_mask</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">photo_bit_binary</span><span class="p">][</span><span class="n">index</span><span class="p">]</span> <span class="o">+</span> <span class="n">df</span><span class="p">[</span><span class="n">classification_binary</span><span class="p">][</span><span class="n">index</span><span class="p">]</span>
        <span class="n">sub_score</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">sum_bit_mask</span><span class="p">(</span><span class="n">bit_mask</span><span class="o">=</span><span class="n">bit_mask</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">sub_score</span> <span class="o">/=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bit_mask</span><span class="p">)</span>
        <span class="n">scores</span><span class="p">[</span><span class="s2">&quot;sub_score&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sub_score</span><span class="p">)</span>

    <span class="n">df</span><span class="p">[</span><span class="n">sub_completeness</span><span class="p">],</span> <span class="n">df</span><span class="p">[</span><span class="n">completeness</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">scores</span><span class="p">[</span><span class="s2">&quot;sub_score&quot;</span><span class="p">],</span>
        <span class="n">scores</span><span class="p">[</span><span class="s2">&quot;cumulative_score&quot;</span><span class="p">],</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">df</span>


<span class="k">def</span> <span class="nf">apply_cleanup</span><span class="p">(</span><span class="n">lc_df</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Applies a full cleanup procedure to the landcover data.</span>
<span class="sd">    It follows the following steps:</span>
<span class="sd">    - Removes Homogenous Columns</span>
<span class="sd">    - Renames Latitude and Longitudes</span>
<span class="sd">    - Cleans the Column Naming</span>
<span class="sd">    - Unpacks landcover classifications</span>
<span class="sd">    - Rounds Columns</span>
<span class="sd">    - Standardizes Null Values</span>

<span class="sd">    This returns a copy</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lc_df : pd.DataFrame</span>
<span class="sd">        A DataFrame containing **raw** Landcover Data from the API.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pd.DataFrame</span>
<span class="sd">        A DataFrame containing the cleaned Landcover Data</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">lc_df</span> <span class="o">=</span> <span class="n">lc_df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">remove_homogenous_cols</span><span class="p">(</span><span class="n">lc_df</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">rename_latlon_cols</span><span class="p">(</span><span class="n">lc_df</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">cleanup_column_prefix</span><span class="p">(</span><span class="n">lc_df</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">lc_df</span> <span class="o">=</span> <span class="n">unpack_classifications</span><span class="p">(</span><span class="n">lc_df</span><span class="p">)</span>
    <span class="n">round_cols</span><span class="p">(</span><span class="n">lc_df</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">standardize_null_vals</span><span class="p">(</span><span class="n">lc_df</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">lc_df</span>


<span class="k">def</span> <span class="nf">add_flags</span><span class="p">(</span><span class="n">lc_df</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Adds the following flags to the landcover data:</span>
<span class="sd">    - Photo Bit Flags</span>
<span class="sd">    - Classification Bit Flags</span>
<span class="sd">    - Completeness Score Flags</span>

<span class="sd">    Returns a copy of the DataFrame</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lc_df : pd.DataFrame</span>
<span class="sd">        A DataFrame containing cleaned up Landcover Data ideally from the [apply_cleanup](#apply_cleanup) method.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pd.DataFrame</span>
<span class="sd">        A DataFrame containing the Land Cover flags.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">lc_df</span> <span class="o">=</span> <span class="n">lc_df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">photo_bit_flags</span><span class="p">(</span><span class="n">lc_df</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">classification_bit_flags</span><span class="p">(</span><span class="n">lc_df</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">get_main_classifications</span><span class="p">(</span><span class="n">lc_df</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">completion_scores</span><span class="p">(</span><span class="n">lc_df</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">lc_df</span>


<span class="k">def</span> <span class="nf">direction_frequency</span><span class="p">(</span><span class="n">lc_df</span><span class="p">,</span> <span class="n">direction_list</span><span class="p">,</span> <span class="n">bit_binary</span><span class="p">,</span> <span class="n">entry_type</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plots the amount of a variable of interest for each direction.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lc_df : pd.DataFrame</span>
<span class="sd">        The DataFrame containing Land Cover Data.</span>
<span class="sd">    direction_list : list of str</span>
<span class="sd">        The column names of the different variables of interest for each direction.</span>
<span class="sd">    bit_binary: str</span>
<span class="sd">        The Bit Binary Flag associated with the variable of interest.</span>
<span class="sd">    entry_type: str</span>
<span class="sd">        The variable of interest (e.g. Photos or Classifications)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">direction_photos</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
    <span class="n">direction_photos</span><span class="p">[</span><span class="s2">&quot;category&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">direction_list</span>
    <span class="n">direction_counts</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">direction_photos</span><span class="p">))]</span>
    <span class="k">for</span> <span class="n">mask</span> <span class="ow">in</span> <span class="n">lc_df</span><span class="p">[</span><span class="n">bit_binary</span><span class="p">]:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">direction_counts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">int</span><span class="p">(</span><span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="n">direction_counts</span>
    <span class="n">direction_photos</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">math</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">direction_counts</span><span class="p">]</span>
    <span class="n">direction_photos</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
    <span class="n">title</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Land Cover -- </span><span class="si">{</span><span class="n">entry_type</span><span class="si">}</span><span class="s2"> Direction Frequency (Log Scale)&quot;</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Count (Log Scale)&quot;</span><span class="p">)</span>
    <span class="n">sns</span><span class="o">.</span><span class="n">barplot</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">direction_photos</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="s2">&quot;category&quot;</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="s2">&quot;count&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;lightblue&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">diagnostic_plots</span><span class="p">(</span>
    <span class="n">lc_df</span><span class="p">,</span>
    <span class="n">up_url</span><span class="o">=</span><span class="s2">&quot;lc_UpwardPhotoUrl&quot;</span><span class="p">,</span>
    <span class="n">down_url</span><span class="o">=</span><span class="s2">&quot;lc_DownwardPhotoUrl&quot;</span><span class="p">,</span>
    <span class="n">north_url</span><span class="o">=</span><span class="s2">&quot;lc_NorthPhotoUrl&quot;</span><span class="p">,</span>
    <span class="n">south_url</span><span class="o">=</span><span class="s2">&quot;lc_SouthPhotoUrl&quot;</span><span class="p">,</span>
    <span class="n">east_url</span><span class="o">=</span><span class="s2">&quot;lc_EastPhotoUrl&quot;</span><span class="p">,</span>
    <span class="n">west_url</span><span class="o">=</span><span class="s2">&quot;lc_WestPhotoUrl&quot;</span><span class="p">,</span>
    <span class="n">photo_bit</span><span class="o">=</span><span class="s2">&quot;lc_PhotoBitBinary&quot;</span><span class="p">,</span>
    <span class="n">north_classification</span><span class="o">=</span><span class="s2">&quot;lc_NorthClassifications&quot;</span><span class="p">,</span>
    <span class="n">south_classification</span><span class="o">=</span><span class="s2">&quot;lc_SouthClassifications&quot;</span><span class="p">,</span>
    <span class="n">east_classification</span><span class="o">=</span><span class="s2">&quot;lc_EastClassifications&quot;</span><span class="p">,</span>
    <span class="n">west_classification</span><span class="o">=</span><span class="s2">&quot;lc_WestClassifications&quot;</span><span class="p">,</span>
    <span class="n">classification_bit</span><span class="o">=</span><span class="s2">&quot;lc_ClassificationBitBinary&quot;</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates (but doesn&#39;t display) diagnostic plots to gain insight into the current data.</span>

<span class="sd">    Plots:</span>
<span class="sd">    - Valid Photo Count Distribution</span>
<span class="sd">    - Photo Distribution by direction</span>
<span class="sd">    - Classification Distribution by direction</span>
<span class="sd">    - Photo Status Distribution</span>
<span class="sd">    - Completeness Score Distribution</span>
<span class="sd">    - Subcompleteness Score Distribution</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lc_df : pd.DataFrame</span>
<span class="sd">        The DataFrame containing Flagged and Cleaned Land Cover Data.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">plot_freq_bar</span><span class="p">(</span>
        <span class="n">lc_df</span><span class="p">,</span> <span class="s2">&quot;Land Cover&quot;</span><span class="p">,</span> <span class="s2">&quot;lc_PhotoCount&quot;</span><span class="p">,</span> <span class="s2">&quot;Valid Photo Count&quot;</span><span class="p">,</span> <span class="n">log_scale</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">)</span>
    <span class="n">direction_frequency</span><span class="p">(</span>
        <span class="n">lc_df</span><span class="p">,</span>
        <span class="p">[</span><span class="n">up_url</span><span class="p">,</span> <span class="n">down_url</span><span class="p">,</span> <span class="n">north_url</span><span class="p">,</span> <span class="n">south_url</span><span class="p">,</span> <span class="n">east_url</span><span class="p">,</span> <span class="n">west_url</span><span class="p">],</span>
        <span class="n">photo_bit</span><span class="p">,</span>
        <span class="s2">&quot;Photo&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">direction_frequency</span><span class="p">(</span>
        <span class="n">lc_df</span><span class="p">,</span>
        <span class="p">[</span>
            <span class="n">north_classification</span><span class="p">,</span>
            <span class="n">south_classification</span><span class="p">,</span>
            <span class="n">east_classification</span><span class="p">,</span>
            <span class="n">west_classification</span><span class="p">,</span>
        <span class="p">],</span>
        <span class="n">classification_bit</span><span class="p">,</span>
        <span class="s2">&quot;Classification&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">multiple_bar_graph</span><span class="p">(</span>
        <span class="n">lc_df</span><span class="p">,</span>
        <span class="s2">&quot;Land Cover&quot;</span><span class="p">,</span>
        <span class="p">[</span><span class="s2">&quot;lc_PhotoCount&quot;</span><span class="p">,</span> <span class="s2">&quot;lc_RejectedCount&quot;</span><span class="p">,</span> <span class="s2">&quot;lc_EmptyCount&quot;</span><span class="p">],</span>
        <span class="s2">&quot;Photo Summary&quot;</span><span class="p">,</span>
        <span class="n">log_scale</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">completeness_histogram</span><span class="p">(</span>
        <span class="n">lc_df</span><span class="p">,</span> <span class="s2">&quot;Land Cover&quot;</span><span class="p">,</span> <span class="s2">&quot;lc_CumulativeCompletenessScore&quot;</span><span class="p">,</span> <span class="s2">&quot;Cumulative Completeness&quot;</span>
    <span class="p">)</span>
    <span class="n">completeness_histogram</span><span class="p">(</span>
        <span class="n">lc_df</span><span class="p">,</span> <span class="s2">&quot;Land Cover&quot;</span><span class="p">,</span> <span class="s2">&quot;lc_SubCompletenessScore&quot;</span><span class="p">,</span> <span class="s2">&quot;Sub Completeness&quot;</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">qa_filter</span><span class="p">(</span>
    <span class="n">lc_df</span><span class="p">,</span>
    <span class="n">has_classification</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">has_photo</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">has_all_photos</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">has_all_classifications</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Can filter a cleaned and flagged mosquito habitat mapper DataFrame based on the following criteria:</span>
<span class="sd">    - `Has Classification`: If the entry has atleast one direction classified</span>
<span class="sd">    - `Has Photo` : If the entry has atleast one photo taken</span>
<span class="sd">    - `Has All Photos` : If the entry has all photos taken (up, down, north, south, east, west)</span>
<span class="sd">    - `Has All Classifications` : If the entry has all directions classified</span>

<span class="sd">    Returns a copy of the DataFrame</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    has_classification : bool, default=False</span>
<span class="sd">        If True, only entries with atleast one classification will be included.</span>
<span class="sd">    has_photo : bool, default=False</span>
<span class="sd">        If True, only entries with atleast one photo will be included.</span>
<span class="sd">    has_all_photos : bool, default=False</span>
<span class="sd">        If True, only entries with all photos will be included.</span>
<span class="sd">    has_all_classifications : bool, default=False</span>
<span class="sd">        If True, only entries with all classifications will be included.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pd.DataFrame</span>
<span class="sd">        A DataFrame of the applied filters.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">has_classification</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">has_all_classifications</span><span class="p">:</span>
        <span class="n">lc_df</span> <span class="o">=</span> <span class="n">lc_df</span><span class="p">[</span><span class="n">lc_df</span><span class="p">[</span><span class="s2">&quot;lc_ClassificationBitDecimal&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">has_all_classifications</span><span class="p">:</span>
        <span class="n">lc_df</span> <span class="o">=</span> <span class="n">lc_df</span><span class="p">[</span><span class="n">lc_df</span><span class="p">[</span><span class="s2">&quot;lc_ClassificationBitDecimal&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">15</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">has_photo</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">has_all_photos</span><span class="p">:</span>
        <span class="n">lc_df</span> <span class="o">=</span> <span class="n">lc_df</span><span class="p">[</span><span class="n">lc_df</span><span class="p">[</span><span class="s2">&quot;lc_PhotoBitDecimal&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">has_all_photos</span><span class="p">:</span>
        <span class="n">lc_df</span> <span class="o">=</span> <span class="n">lc_df</span><span class="p">[</span><span class="n">lc_df</span><span class="p">[</span><span class="s2">&quot;lc_PhotoBitDecimal&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">63</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">lc_df</span>


<span class="k">def</span> <span class="nf">_accumulate_ties</span><span class="p">(</span><span class="n">classification_list</span><span class="p">):</span>
    <span class="n">classifications</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">classification_list</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">classification_list</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">classification_list</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">classifications</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">classification_list</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">classifications</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">classification_list</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">break</span>

    <span class="n">output</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">classification</span> <span class="k">for</span> <span class="n">classification</span> <span class="ow">in</span> <span class="n">classifications</span><span class="p">])</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">output</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">classification_list</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">output</span> <span class="o">=</span> <span class="n">classification_list</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">output</span> <span class="o">=</span> <span class="s2">&quot;NA&quot;</span>
    <span class="c1"># TODO replace w regex methods</span>
    <span class="k">return</span> <span class="n">output</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>


<span class="k">def</span> <span class="nf">_rank_direction</span><span class="p">(</span><span class="n">classification_dict</span><span class="p">,</span> <span class="n">direction_classifications</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">isna</span><span class="p">(</span><span class="n">direction_classifications</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;NA&quot;</span><span class="p">,</span> <span class="s2">&quot;NA&quot;</span>
    <span class="n">classifications_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">classifications</span> <span class="o">=</span> <span class="n">direction_classifications</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;;&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">classification_data</span> <span class="ow">in</span> <span class="n">classifications</span><span class="p">:</span>
        <span class="n">percent</span> <span class="o">=</span> <span class="n">extract_classification_percentage</span><span class="p">(</span><span class="n">classification_data</span><span class="p">)</span>
        <span class="n">classification</span> <span class="o">=</span> <span class="n">extract_classification_name</span><span class="p">(</span><span class="n">classification_data</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">classification</span> <span class="ow">in</span> <span class="n">classification_dict</span><span class="p">:</span>
            <span class="n">classification_dict</span><span class="p">[</span><span class="n">classification</span><span class="p">]</span> <span class="o">+=</span> <span class="n">percent</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">classification_dict</span><span class="p">[</span><span class="n">classification</span><span class="p">]</span> <span class="o">=</span> <span class="n">percent</span>
        <span class="n">classifications_list</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">classification</span><span class="p">,</span> <span class="n">percent</span><span class="p">))</span>
    <span class="n">classifications_list</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
        <span class="n">classifications_list</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">classifications_list</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">classifications_list</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;NA&quot;</span>

    <span class="n">primary_classification</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="n">_accumulate_ties</span><span class="p">(</span><span class="n">classifications_list</span><span class="p">)</span>
    <span class="n">secondary_classification</span><span class="p">,</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">_accumulate_ties</span><span class="p">(</span><span class="n">classifications_list</span><span class="p">[</span><span class="n">i</span><span class="p">:])</span>

    <span class="k">return</span> <span class="n">primary_classification</span><span class="p">,</span> <span class="n">secondary_classification</span>


<span class="k">def</span> <span class="nf">_rank_classifications</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="n">classification_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">rank_directions</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">classification</span>
        <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span>
        <span class="k">for</span> <span class="n">classification</span> <span class="ow">in</span> <span class="n">_rank_direction</span><span class="p">(</span><span class="n">classification_dict</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span>
    <span class="p">]</span>
    <span class="n">primary</span><span class="p">,</span> <span class="n">secondary</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;NA&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;NA&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">classification_dict</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">classification_dict</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">primary</span> <span class="o">=</span> <span class="p">(</span>
                <span class="nb">list</span><span class="p">(</span><span class="n">classification_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">],</span>
                <span class="nb">list</span><span class="p">(</span><span class="n">classification_dict</span><span class="o">.</span><span class="n">values</span><span class="p">())[</span><span class="mi">0</span><span class="p">],</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sorted_classifications</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
                <span class="n">classification_dict</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
            <span class="n">primary</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="n">_accumulate_ties</span><span class="p">(</span><span class="n">sorted_classifications</span><span class="p">)</span>
            <span class="n">primary</span> <span class="o">=</span> <span class="n">primary</span><span class="p">,</span> <span class="n">sorted_classifications</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">sorted_classifications</span><span class="p">):</span>
                <span class="n">secondary</span><span class="p">,</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">_accumulate_ties</span><span class="p">(</span><span class="n">sorted_classifications</span><span class="p">[</span><span class="n">i</span><span class="p">:])</span>
                <span class="n">secondary</span> <span class="o">=</span> <span class="n">secondary</span><span class="p">,</span> <span class="n">sorted_classifications</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="p">(</span>
        <span class="o">*</span><span class="n">rank_directions</span><span class="p">,</span>
        <span class="n">primary</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
        <span class="n">secondary</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
        <span class="n">primary</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">),</span>
        <span class="n">secondary</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">),</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">get_main_classifications</span><span class="p">(</span>
    <span class="n">lc_df</span><span class="p">,</span>
    <span class="n">north_classification</span><span class="o">=</span><span class="s2">&quot;lc_NorthClassifications&quot;</span><span class="p">,</span>
    <span class="n">east_classification</span><span class="o">=</span><span class="s2">&quot;lc_EastClassifications&quot;</span><span class="p">,</span>
    <span class="n">south_classification</span><span class="o">=</span><span class="s2">&quot;lc_SouthClassifications&quot;</span><span class="p">,</span>
    <span class="n">west_classification</span><span class="o">=</span><span class="s2">&quot;lc_WestClassifications&quot;</span><span class="p">,</span>
    <span class="n">north_primary</span><span class="o">=</span><span class="s2">&quot;lc_NorthPrimary&quot;</span><span class="p">,</span>
    <span class="n">north_secondary</span><span class="o">=</span><span class="s2">&quot;lc_NorthSecondary&quot;</span><span class="p">,</span>
    <span class="n">east_primary</span><span class="o">=</span><span class="s2">&quot;lc_EastPrimary&quot;</span><span class="p">,</span>
    <span class="n">east_secondary</span><span class="o">=</span><span class="s2">&quot;lc_EastSecondary&quot;</span><span class="p">,</span>
    <span class="n">south_primary</span><span class="o">=</span><span class="s2">&quot;lc_SouthPrimary&quot;</span><span class="p">,</span>
    <span class="n">south_secondary</span><span class="o">=</span><span class="s2">&quot;lc_SouthSecondary&quot;</span><span class="p">,</span>
    <span class="n">west_primary</span><span class="o">=</span><span class="s2">&quot;lc_WestPrimary&quot;</span><span class="p">,</span>
    <span class="n">west_secondary</span><span class="o">=</span><span class="s2">&quot;lc_WestSecondary&quot;</span><span class="p">,</span>
    <span class="n">primary_classification</span><span class="o">=</span><span class="s2">&quot;lc_PrimaryClassification&quot;</span><span class="p">,</span>
    <span class="n">secondary_classification</span><span class="o">=</span><span class="s2">&quot;lc_SecondaryClassification&quot;</span><span class="p">,</span>
    <span class="n">primary_percentage</span><span class="o">=</span><span class="s2">&quot;lc_PrimaryPercentage&quot;</span><span class="p">,</span>
    <span class="n">secondary_percentage</span><span class="o">=</span><span class="s2">&quot;lc_SecondaryPercentage&quot;</span><span class="p">,</span>
    <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span>
        <span class="n">lc_df</span> <span class="o">=</span> <span class="n">lc_df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">vectorized_rank</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">_rank_classifications</span><span class="p">)</span>
    <span class="p">(</span>
        <span class="n">lc_df</span><span class="p">[</span><span class="n">north_primary</span><span class="p">],</span>
        <span class="n">lc_df</span><span class="p">[</span><span class="n">north_secondary</span><span class="p">],</span>
        <span class="n">lc_df</span><span class="p">[</span><span class="n">east_primary</span><span class="p">],</span>
        <span class="n">lc_df</span><span class="p">[</span><span class="n">east_secondary</span><span class="p">],</span>
        <span class="n">lc_df</span><span class="p">[</span><span class="n">south_primary</span><span class="p">],</span>
        <span class="n">lc_df</span><span class="p">[</span><span class="n">south_secondary</span><span class="p">],</span>
        <span class="n">lc_df</span><span class="p">[</span><span class="n">west_primary</span><span class="p">],</span>
        <span class="n">lc_df</span><span class="p">[</span><span class="n">west_secondary</span><span class="p">],</span>
        <span class="n">lc_df</span><span class="p">[</span><span class="n">primary_classification</span><span class="p">],</span>
        <span class="n">lc_df</span><span class="p">[</span><span class="n">secondary_classification</span><span class="p">],</span>
        <span class="n">lc_df</span><span class="p">[</span><span class="n">primary_percentage</span><span class="p">],</span>
        <span class="n">lc_df</span><span class="p">[</span><span class="n">secondary_percentage</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">=</span> <span class="n">vectorized_rank</span><span class="p">(</span>
        <span class="n">lc_df</span><span class="p">[</span><span class="n">north_classification</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(),</span>
        <span class="n">lc_df</span><span class="p">[</span><span class="n">east_classification</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(),</span>
        <span class="n">lc_df</span><span class="p">[</span><span class="n">south_classification</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(),</span>
        <span class="n">lc_df</span><span class="p">[</span><span class="n">west_classification</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(),</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">lc_df</span>
</pre></div>

        </details>

            </section>
                <section id="cleanup_column_prefix">
                            <div class="attr function"><a class="headerlink" href="#cleanup_column_prefix">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">cleanup_column_prefix</span><span class="signature">(df, inplace=False)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">cleanup_column_prefix</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Method for shortening raw landcover column names.</span>

<span class="sd">    The df object will now replace the verbose `landcovers` prefix in some of the columns with `lc_`</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    df : pd.DataFrame</span>
<span class="sd">        The DataFrame containing raw landcover data. The DataFrame object itself will be modified.</span>
<span class="sd">    inplace : bool, default=False</span>
<span class="sd">        Whether to return a new DataFrame. If True then no DataFrame copy is not returned and the operation is performed in place.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pd.DataFrame or None</span>
<span class="sd">        A DataFrame with the cleaned up column prefixes. If `inplace=True` it returns None.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">replace_column_prefix</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="s2">&quot;landcovers&quot;</span><span class="p">,</span> <span class="s2">&quot;lc&quot;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">df</span>
</pre></div>

        </details>

            <div class="docstring"><p>Method for shortening raw landcover column names.</p>

<p>The df object will now replace the verbose <code>landcovers</code> prefix in some of the columns with <code>lc_</code></p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>df</strong> (pd.DataFrame):
The DataFrame containing raw landcover data. The DataFrame object itself will be modified.</li>
<li><strong>inplace</strong> (bool, default=False):
Whether to return a new DataFrame. If True then no DataFrame copy is not returned and the operation is performed in place.</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>pd.DataFrame or None</strong>: A DataFrame with the cleaned up column prefixes. If <code>inplace=True</code> it returns None.</li>
</ul>
</div>


                </section>
                <section id="extract_classification_name">
                            <div class="attr function"><a class="headerlink" href="#extract_classification_name">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">extract_classification_name</span><span class="signature">(entry)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">extract_classification_name</span><span class="p">(</span><span class="n">entry</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extracts the name (landcover description) of a singular landcover classification. For example in the classification of `&quot;60% MUC 02 (b) [Trees, Closely Spaced, Deciduous - Broad Leaved]&quot;`, the `&quot;Trees, Closely Spaced, Deciduous - Broad Leaved&quot;` is extracted.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    entry : str</span>
<span class="sd">        A single landcover classification.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    str</span>
<span class="sd">        The Landcover description of a classification</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(?&lt;=\[).*(?=\])&quot;</span><span class="p">,</span> <span class="n">entry</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">()</span>
</pre></div>

        </details>

            <div class="docstring"><p>Extracts the name (landcover description) of a singular landcover classification. For example in the classification of <code>"60% MUC 02 (b) [Trees, Closely Spaced, Deciduous - Broad Leaved]"</code>, the <code>"Trees, Closely Spaced, Deciduous - Broad Leaved"</code> is extracted.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>entry</strong> (str):
A single landcover classification.</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>str</strong>: The Landcover description of a classification</li>
</ul>
</div>


                </section>
                <section id="extract_classification_percentage">
                            <div class="attr function"><a class="headerlink" href="#extract_classification_percentage">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">extract_classification_percentage</span><span class="signature">(entry)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">extract_classification_percentage</span><span class="p">(</span><span class="n">entry</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extracts the percentage of a singular landcover classification. For example in the classification of `&quot;60% MUC 02 (b) [Trees, Closely Spaced, Deciduous - Broad Leaved]&quot;`, the `60` is extracted.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    entry : str</span>
<span class="sd">        A single landcover classification.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float</span>
<span class="sd">        The percentage of a landcover classification</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s2">&quot;.*(?=%)&quot;</span><span class="p">,</span> <span class="n">entry</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">())</span>
</pre></div>

        </details>

            <div class="docstring"><p>Extracts the percentage of a singular landcover classification. For example in the classification of <code>"60% MUC 02 (b) [Trees, Closely Spaced, Deciduous - Broad Leaved]"</code>, the <code>60</code> is extracted.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>entry</strong> (str):
A single landcover classification.</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>float</strong>: The percentage of a landcover classification</li>
</ul>
</div>


                </section>
                <section id="extract_classifications">
                            <div class="attr function"><a class="headerlink" href="#extract_classifications">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">extract_classifications</span><span class="signature">(info)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">extract_classifications</span><span class="p">(</span><span class="n">info</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Extracts the name/landcover description (see [here](#extract_classification_name) for a clearer definition) of a landcover classification entry in the GLOBE Observer Data.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    info : str</span>
<span class="sd">        A string representing a landcover classification entry in the GLOBE Observer Datset.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list of str</span>
<span class="sd">        The different landcover classifications stored within the landcover entry.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_extract_landcover_items</span><span class="p">(</span><span class="n">extract_classification_name</span><span class="p">,</span> <span class="n">info</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Extracts the name/landcover description (see <a href="#extract_classification_name">here</a> for a clearer definition) of a landcover classification entry in the GLOBE Observer Data.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>info</strong> (str):
A string representing a landcover classification entry in the GLOBE Observer Datset.</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>list of str</strong>: The different landcover classifications stored within the landcover entry.</li>
</ul>
</div>


                </section>
                <section id="extract_percentages">
                            <div class="attr function"><a class="headerlink" href="#extract_percentages">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">extract_percentages</span><span class="signature">(info)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">extract_percentages</span><span class="p">(</span><span class="n">info</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Extracts the percentages (see [here](#extract_classification_percentage) for a clearer definition) of a landcover classification in the GLOBE Observer Datset.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    info : str</span>
<span class="sd">        A string representing a landcover classification entry in the GLOBE Observer Datset.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list of float</span>
<span class="sd">        The different landcover percentages stored within the landcover entry.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">_extract_landcover_items</span><span class="p">(</span><span class="n">extract_classification_percentage</span><span class="p">,</span> <span class="n">info</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Extracts the percentages (see <a href="#extract_classification_percentage">here</a> for a clearer definition) of a landcover classification in the GLOBE Observer Datset.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>info</strong> (str):
A string representing a landcover classification entry in the GLOBE Observer Datset.</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>list of float</strong>: The different landcover percentages stored within the landcover entry.</li>
</ul>
</div>


                </section>
                <section id="extract_classification_dict">
                            <div class="attr function"><a class="headerlink" href="#extract_classification_dict">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">extract_classification_dict</span><span class="signature">(info)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">extract_classification_dict</span><span class="p">(</span><span class="n">info</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Extracts the landcover descriptions and percentages of a landcover classification entry as a dictionary.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    info : str</span>
<span class="sd">        A string representing a landcover classification entry in the GLOBE Observer Datset.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict of str, float</span>
<span class="sd">        The landcover descriptions and percentages stored as a dict in the form: `{&quot;description&quot; : percentage}`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">entries</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;;&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="n">extract_classification_name</span><span class="p">(</span><span class="n">entry</span><span class="p">):</span> <span class="n">extract_classification_percentage</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">entries</span>
    <span class="p">}</span>
</pre></div>

        </details>

            <div class="docstring"><p>Extracts the landcover descriptions and percentages of a landcover classification entry as a dictionary.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>info</strong> (str):
A string representing a landcover classification entry in the GLOBE Observer Datset.</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>dict of str, float</strong>: The landcover descriptions and percentages stored as a dict in the form: <code>{"description" : percentage}</code>.</li>
</ul>
</div>


                </section>
                <section id="unpack_classifications">
                            <div class="attr function"><a class="headerlink" href="#unpack_classifications">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">unpack_classifications</span><span class="signature">(
    lc_df,
    north=&#39;lc_NorthClassifications&#39;,
    east=&#39;lc_EastClassifications&#39;,
    south=&#39;lc_SouthClassifications&#39;,
    west=&#39;lc_WestClassifications&#39;,
    ref_col=&#39;lc_pid&#39;
)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">unpack_classifications</span><span class="p">(</span>
    <span class="n">lc_df</span><span class="p">,</span>
    <span class="n">north</span><span class="o">=</span><span class="s2">&quot;lc_NorthClassifications&quot;</span><span class="p">,</span>
    <span class="n">east</span><span class="o">=</span><span class="s2">&quot;lc_EastClassifications&quot;</span><span class="p">,</span>
    <span class="n">south</span><span class="o">=</span><span class="s2">&quot;lc_SouthClassifications&quot;</span><span class="p">,</span>
    <span class="n">west</span><span class="o">=</span><span class="s2">&quot;lc_WestClassifications&quot;</span><span class="p">,</span>
    <span class="n">ref_col</span><span class="o">=</span><span class="s2">&quot;lc_pid&quot;</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Unpacks the classification data in the *raw* GLOBE Observer Landcover data. This method assumes that the columns have been renamed with accordance to the [column cleanup](#cleanup_column_prefix) method.</span>

<span class="sd">    This returns a copy of the dataframe.</span>

<span class="sd">    See [here](#unpacking-the-landcover-classification-data) for more information.</span>

<span class="sd">    *Note:* The returned DataFrame will have around 250 columns.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lc_df : pd.DataFrame</span>
<span class="sd">        A DataFrame containing Raw GLOBE Observer Landcover data that has had the column names simplified.</span>
<span class="sd">    north: str, default=&quot;lc_NorthClassifications&quot;</span>
<span class="sd">        The name of the column which contains the North Classifications</span>
<span class="sd">    east: str, default=&quot;lc_EastClassifications&quot;</span>
<span class="sd">        The name of the column which contains the East Classifications</span>
<span class="sd">    south: str, default=&quot;lc_SouthClassifications&quot;</span>
<span class="sd">        The name of the column which contains the South Classifications</span>
<span class="sd">    west: str, default=&quot;lc_WestClassifications&quot;</span>
<span class="sd">        The name of the column which contains the West Classifications</span>
<span class="sd">    west: str, default=&quot;lc_pid&quot;</span>
<span class="sd">        The name of the column which all of the expanded values will be placed after. For example, if the columns were `[1, 2, 3, 4]` and you chose 3, the new columns will now be `[1, 2, 3, (all classification columns), 4]`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pd.DataFrame</span>
<span class="sd">        A DataFrame with the unpacked classification columns.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">classifications</span> <span class="o">=</span> <span class="p">[</span><span class="n">north</span><span class="p">,</span> <span class="n">east</span><span class="p">,</span> <span class="n">south</span><span class="p">,</span> <span class="n">west</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">set_directions</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">classification</span> <span class="ow">in</span> <span class="n">classifications</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">classification</span><span class="p">]):</span>
                <span class="n">entries</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">classification</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;;&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">entries</span><span class="p">:</span>
                    <span class="n">percent</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">extract_classification_percentage</span><span class="p">(</span><span class="n">entry</span><span class="p">),</span>
                        <span class="n">extract_classification_name</span><span class="p">(</span><span class="n">entry</span><span class="p">),</span>
                    <span class="p">)</span>
                    <span class="n">name</span> <span class="o">=</span> <span class="n">camel_case</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="s2">&quot;,&quot;</span><span class="p">,</span> <span class="s2">&quot;-&quot;</span><span class="p">,</span> <span class="s2">&quot;/&quot;</span><span class="p">])</span>
                    <span class="n">classification</span> <span class="o">=</span> <span class="n">classification</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;Classifications&quot;</span><span class="p">,</span> <span class="s2">&quot;_&quot;</span><span class="p">)</span>
                    <span class="n">overall</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span>
                        <span class="sa">r</span><span class="s2">&quot;(north|south|east|west).*&quot;</span><span class="p">,</span>
                        <span class="s2">&quot;Overall_&quot;</span><span class="p">,</span>
                        <span class="n">key</span><span class="p">,</span>
                        <span class="n">flags</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">row</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">classification</span><span class="si">}{</span><span class="n">name</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">percent</span>
                    <span class="n">row</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">overall</span><span class="si">}{</span><span class="n">name</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="n">percent</span>
        <span class="k">return</span> <span class="n">row</span>

    <span class="n">land_type_columns_to_add</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">classification</span><span class="p">:</span> <span class="n">_get_classifications_for_direction</span><span class="p">(</span><span class="n">lc_df</span><span class="p">,</span> <span class="n">classification</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">classification</span> <span class="ow">in</span> <span class="n">classifications</span>
    <span class="p">}</span>
    <span class="n">overall_columns</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">values</span> <span class="ow">in</span> <span class="n">land_type_columns_to_add</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">direction_name</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;Classifications&quot;</span><span class="p">,</span> <span class="s2">&quot;_&quot;</span><span class="p">)</span>
        <span class="n">overall</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span>
            <span class="sa">r</span><span class="s2">&quot;(north|south|east|west).*&quot;</span><span class="p">,</span> <span class="s2">&quot;Overall_&quot;</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">values</span><span class="p">:</span>
            <span class="n">lc_df</span><span class="p">[</span><span class="n">direction_name</span> <span class="o">+</span> <span class="n">value</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">lc_df</span><span class="p">[</span><span class="n">overall</span> <span class="o">+</span> <span class="n">value</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">overall_columns</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">overall</span> <span class="o">+</span> <span class="n">value</span><span class="p">)</span>
    <span class="n">direction_data_cols</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="n">name</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">lc_df</span><span class="o">.</span><span class="n">columns</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span>
                <span class="n">direction</span> <span class="ow">in</span> <span class="n">name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">direction</span> <span class="ow">in</span> <span class="p">(</span>
                    <span class="s2">&quot;downward&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;upward&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;west&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;east&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;north&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;south&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;overall&quot;</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="p">]</span>
    <span class="p">)</span>
    <span class="n">lc_df</span> <span class="o">=</span> <span class="n">_move_cols</span><span class="p">(</span><span class="n">lc_df</span><span class="p">,</span> <span class="n">cols_to_move</span><span class="o">=</span><span class="n">direction_data_cols</span><span class="p">,</span> <span class="n">ref_col</span><span class="o">=</span><span class="n">ref_col</span><span class="p">)</span>
    <span class="n">lc_df</span> <span class="o">=</span> <span class="n">lc_df</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">set_directions</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">overall_columns</span><span class="p">:</span>
        <span class="n">lc_df</span><span class="p">[</span><span class="n">column</span><span class="p">]</span> <span class="o">/=</span> <span class="mi">4</span>
    <span class="k">return</span> <span class="n">lc_df</span>
</pre></div>

        </details>

            <div class="docstring"><p>Unpacks the classification data in the <em>raw</em> GLOBE Observer Landcover data. This method assumes that the columns have been renamed with accordance to the <a href="#cleanup_column_prefix">column cleanup</a> method.</p>

<p>This returns a copy of the dataframe.</p>

<p>See <a href="#unpacking-the-landcover-classification-data">here</a> for more information.</p>

<p><em>Note:</em> The returned DataFrame will have around 250 columns.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>lc_df</strong> (pd.DataFrame):
A DataFrame containing Raw GLOBE Observer Landcover data that has had the column names simplified.</li>
<li><strong>north</strong> (str, default="lc_NorthClassifications"):
The name of the column which contains the North Classifications</li>
<li><strong>east</strong> (str, default="lc_EastClassifications"):
The name of the column which contains the East Classifications</li>
<li><strong>south</strong> (str, default="lc_SouthClassifications"):
The name of the column which contains the South Classifications</li>
<li><strong>west</strong> (str, default="lc_WestClassifications"):
The name of the column which contains the West Classifications</li>
<li><strong>west</strong> (str, default="lc_pid"):
The name of the column which all of the expanded values will be placed after. For example, if the columns were <code>[1, 2, 3, 4]</code> and you chose 3, the new columns will now be <code>[1, 2, 3, (all classification columns), 4]</code>.</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>pd.DataFrame</strong>: A DataFrame with the unpacked classification columns.</li>
</ul>
</div>


                </section>
                <section id="photo_bit_flags">
                            <div class="attr function"><a class="headerlink" href="#photo_bit_flags">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">photo_bit_flags</span><span class="signature">(
    df,
    up=&#39;lc_UpwardPhotoUrl&#39;,
    down=&#39;lc_DownwardPhotoUrl&#39;,
    north=&#39;lc_NorthPhotoUrl&#39;,
    south=&#39;lc_SouthPhotoUrl&#39;,
    east=&#39;lc_EastPhotoUrl&#39;,
    west=&#39;lc_WestPhotoUrl&#39;,
    photo_count=&#39;lc_PhotoCount&#39;,
    rejected_count=&#39;lc_RejectedCount&#39;,
    pending_count=&#39;lc_PendingCount&#39;,
    empty_count=&#39;lc_EmptyCount&#39;,
    bit_binary=&#39;lc_PhotoBitBinary&#39;,
    bit_decimal=&#39;lc_PhotoBitDecimal&#39;,
    inplace=False
)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">photo_bit_flags</span><span class="p">(</span>
    <span class="n">df</span><span class="p">,</span>
    <span class="n">up</span><span class="o">=</span><span class="s2">&quot;lc_UpwardPhotoUrl&quot;</span><span class="p">,</span>
    <span class="n">down</span><span class="o">=</span><span class="s2">&quot;lc_DownwardPhotoUrl&quot;</span><span class="p">,</span>
    <span class="n">north</span><span class="o">=</span><span class="s2">&quot;lc_NorthPhotoUrl&quot;</span><span class="p">,</span>
    <span class="n">south</span><span class="o">=</span><span class="s2">&quot;lc_SouthPhotoUrl&quot;</span><span class="p">,</span>
    <span class="n">east</span><span class="o">=</span><span class="s2">&quot;lc_EastPhotoUrl&quot;</span><span class="p">,</span>
    <span class="n">west</span><span class="o">=</span><span class="s2">&quot;lc_WestPhotoUrl&quot;</span><span class="p">,</span>
    <span class="n">photo_count</span><span class="o">=</span><span class="s2">&quot;lc_PhotoCount&quot;</span><span class="p">,</span>
    <span class="n">rejected_count</span><span class="o">=</span><span class="s2">&quot;lc_RejectedCount&quot;</span><span class="p">,</span>
    <span class="n">pending_count</span><span class="o">=</span><span class="s2">&quot;lc_PendingCount&quot;</span><span class="p">,</span>
    <span class="n">empty_count</span><span class="o">=</span><span class="s2">&quot;lc_EmptyCount&quot;</span><span class="p">,</span>
    <span class="n">bit_binary</span><span class="o">=</span><span class="s2">&quot;lc_PhotoBitBinary&quot;</span><span class="p">,</span>
    <span class="n">bit_decimal</span><span class="o">=</span><span class="s2">&quot;lc_PhotoBitDecimal&quot;</span><span class="p">,</span>
    <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates the following flags:</span>
<span class="sd">    - `PhotoCount`: The number of valid photos per record.</span>
<span class="sd">    - `RejectedCount`: The number of photos that were rejected per record.</span>
<span class="sd">    - `PendingCount`: The number of photos that are pending approval per record.</span>
<span class="sd">    - `PhotoBitBinary`: A string that represents the presence of a photo in the Up, Down, North, South, East, and West directions. For example, if the entry is `110100`, that indicates that there is a valid photo for the Up, Down, and South Directions but no valid photos for the North, East, and West Directions.</span>
<span class="sd">    - `PhotoBitDecimal`: The numerical representation of the lc_PhotoBitBinary string.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    df : pd.DataFrame</span>
<span class="sd">        A land cover DataFrame</span>
<span class="sd">    up : str, default=&quot;lc_UpwardPhotoUrl&quot;</span>
<span class="sd">        The name of the column in the land cover DataFrame that contains the url for the upwards photo.</span>
<span class="sd">    down : str, default=&quot;lc_DownwardPhotoUrl&quot;</span>
<span class="sd">        The name of the column in the land cover DataFrame that contains the url for the downwards photo.</span>
<span class="sd">    north : str, default=&quot;lc_NorthPhotoUrl&quot;</span>
<span class="sd">        The name of the column in the land cover DataFrame that contains the url for the north photo.</span>
<span class="sd">    south : str, default=&quot;lc_SouthPhotoUrl&quot;</span>
<span class="sd">        The name of the column in the land cover DataFrame that contains the url for the south photo.</span>
<span class="sd">    east : str, default=&quot;lc_EastPhotoUrl&quot;</span>
<span class="sd">        The name of the column in the land cover DataFrame that contains the url for the east photo.</span>
<span class="sd">    west : str, default=&quot;lc_WestPhotoUrl&quot;</span>
<span class="sd">        The name of the column in the land cover DataFrame that contains the url for the west photo.</span>
<span class="sd">    photo_count : str, default=&quot;lc_PhotoCount&quot;</span>
<span class="sd">        The name of the column that will be storing the PhotoCount flag.</span>
<span class="sd">    rejected_count : str, default=&quot;lc_RejectedCount&quot;</span>
<span class="sd">        The name of the column that will be storing the RejectedCount flag.</span>
<span class="sd">    pending_count : str, default=&quot;lc_PendingCount&quot;</span>
<span class="sd">        The name of the column that will be storing the PendingCount flag.</span>
<span class="sd">    empty_count : str, default=&quot;lc_EmptyCount&quot;</span>
<span class="sd">        The name of the column that will be storing the EmptyCount flag.</span>
<span class="sd">    bit_binary : str, default=&quot;lc_PhotoBitBinary&quot;</span>
<span class="sd">        The name of the column that will be storing the PhotoBitBinary flag.</span>
<span class="sd">    bit_decimal : str, default=&quot;lc_PhotoBitDecimal&quot;</span>
<span class="sd">        The name of the column that will be storing the PhotoBitDecimal flag.</span>
<span class="sd">    inplace : bool, default=False</span>
<span class="sd">        Whether to return a new DataFrame. If True then no DataFrame copy is not returned and the operation is performed in place.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pd.DataFrame or None</span>
<span class="sd">        A DataFrame with the photo bit flags. If `inplace=True` it returns None.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">pic_data</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="n">pic_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">rejected_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">pending_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">empty_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">valid_photo_bit_mask</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

        <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">pd</span><span class="o">.</span><span class="n">isna</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span> <span class="ow">and</span> <span class="s2">&quot;http&quot;</span> <span class="ow">in</span> <span class="n">entry</span><span class="p">:</span>
                <span class="n">valid_photo_bit_mask</span> <span class="o">+=</span> <span class="s2">&quot;1&quot;</span>
                <span class="n">pic_count</span> <span class="o">+=</span> <span class="n">entry</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s2">&quot;http&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">valid_photo_bit_mask</span> <span class="o">+=</span> <span class="s2">&quot;0&quot;</span>
            <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">isna</span><span class="p">(</span><span class="n">entry</span><span class="p">):</span>
                <span class="n">empty_count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pending_count</span> <span class="o">+=</span> <span class="n">entry</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s2">&quot;pending&quot;</span><span class="p">)</span>
                <span class="n">rejected_count</span> <span class="o">+=</span> <span class="n">entry</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s2">&quot;rejected&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">pic_count</span><span class="p">,</span>
            <span class="n">rejected_count</span><span class="p">,</span>
            <span class="n">pending_count</span><span class="p">,</span>
            <span class="n">empty_count</span><span class="p">,</span>
            <span class="n">valid_photo_bit_mask</span><span class="p">,</span>
            <span class="nb">int</span><span class="p">(</span><span class="n">valid_photo_bit_mask</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">get_photo_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">pic_data</span><span class="p">)</span>
    <span class="p">(</span>
        <span class="n">df</span><span class="p">[</span><span class="n">photo_count</span><span class="p">],</span>
        <span class="n">df</span><span class="p">[</span><span class="n">rejected_count</span><span class="p">],</span>
        <span class="n">df</span><span class="p">[</span><span class="n">pending_count</span><span class="p">],</span>
        <span class="n">df</span><span class="p">[</span><span class="n">empty_count</span><span class="p">],</span>
        <span class="n">df</span><span class="p">[</span><span class="n">bit_binary</span><span class="p">],</span>
        <span class="n">df</span><span class="p">[</span><span class="n">bit_decimal</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">=</span> <span class="n">get_photo_data</span><span class="p">(</span>
        <span class="n">df</span><span class="p">[</span><span class="n">up</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(),</span>
        <span class="n">df</span><span class="p">[</span><span class="n">down</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(),</span>
        <span class="n">df</span><span class="p">[</span><span class="n">north</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(),</span>
        <span class="n">df</span><span class="p">[</span><span class="n">south</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(),</span>
        <span class="n">df</span><span class="p">[</span><span class="n">east</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(),</span>
        <span class="n">df</span><span class="p">[</span><span class="n">west</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(),</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">df</span>
</pre></div>

        </details>

            <div class="docstring"><p>Creates the following flags:</p>

<ul>
<li><code>PhotoCount</code>: The number of valid photos per record.</li>
<li><code>RejectedCount</code>: The number of photos that were rejected per record.</li>
<li><code>PendingCount</code>: The number of photos that are pending approval per record.</li>
<li><code>PhotoBitBinary</code>: A string that represents the presence of a photo in the Up, Down, North, South, East, and West directions. For example, if the entry is <code>110100</code>, that indicates that there is a valid photo for the Up, Down, and South Directions but no valid photos for the North, East, and West Directions.</li>
<li><code>PhotoBitDecimal</code>: The numerical representation of the lc_PhotoBitBinary string.</li>
</ul>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>df</strong> (pd.DataFrame):
A land cover DataFrame</li>
<li><strong>up</strong> (str, default="lc_UpwardPhotoUrl"):
The name of the column in the land cover DataFrame that contains the url for the upwards photo.</li>
<li><strong>down</strong> (str, default="lc_DownwardPhotoUrl"):
The name of the column in the land cover DataFrame that contains the url for the downwards photo.</li>
<li><strong>north</strong> (str, default="lc_NorthPhotoUrl"):
The name of the column in the land cover DataFrame that contains the url for the north photo.</li>
<li><strong>south</strong> (str, default="lc_SouthPhotoUrl"):
The name of the column in the land cover DataFrame that contains the url for the south photo.</li>
<li><strong>east</strong> (str, default="lc_EastPhotoUrl"):
The name of the column in the land cover DataFrame that contains the url for the east photo.</li>
<li><strong>west</strong> (str, default="lc_WestPhotoUrl"):
The name of the column in the land cover DataFrame that contains the url for the west photo.</li>
<li><strong>photo_count</strong> (str, default="lc_PhotoCount"):
The name of the column that will be storing the PhotoCount flag.</li>
<li><strong>rejected_count</strong> (str, default="lc_RejectedCount"):
The name of the column that will be storing the RejectedCount flag.</li>
<li><strong>pending_count</strong> (str, default="lc_PendingCount"):
The name of the column that will be storing the PendingCount flag.</li>
<li><strong>empty_count</strong> (str, default="lc_EmptyCount"):
The name of the column that will be storing the EmptyCount flag.</li>
<li><strong>bit_binary</strong> (str, default="lc_PhotoBitBinary"):
The name of the column that will be storing the PhotoBitBinary flag.</li>
<li><strong>bit_decimal</strong> (str, default="lc_PhotoBitDecimal"):
The name of the column that will be storing the PhotoBitDecimal flag.</li>
<li><strong>inplace</strong> (bool, default=False):
Whether to return a new DataFrame. If True then no DataFrame copy is not returned and the operation is performed in place.</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>pd.DataFrame or None</strong>: A DataFrame with the photo bit flags. If <code>inplace=True</code> it returns None.</li>
</ul>
</div>


                </section>
                <section id="classification_bit_flags">
                            <div class="attr function"><a class="headerlink" href="#classification_bit_flags">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">classification_bit_flags</span><span class="signature">(
    df,
    north=&#39;lc_NorthClassifications&#39;,
    south=&#39;lc_SouthClassifications&#39;,
    east=&#39;lc_EastClassifications&#39;,
    west=&#39;lc_WestClassifications&#39;,
    classification_count=&#39;lc_ClassificationCount&#39;,
    bit_binary=&#39;lc_ClassificationBitBinary&#39;,
    bit_decimal=&#39;lc_ClassificationBitDecimal&#39;,
    inplace=False
)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">classification_bit_flags</span><span class="p">(</span>
    <span class="n">df</span><span class="p">,</span>
    <span class="n">north</span><span class="o">=</span><span class="s2">&quot;lc_NorthClassifications&quot;</span><span class="p">,</span>
    <span class="n">south</span><span class="o">=</span><span class="s2">&quot;lc_SouthClassifications&quot;</span><span class="p">,</span>
    <span class="n">east</span><span class="o">=</span><span class="s2">&quot;lc_EastClassifications&quot;</span><span class="p">,</span>
    <span class="n">west</span><span class="o">=</span><span class="s2">&quot;lc_WestClassifications&quot;</span><span class="p">,</span>
    <span class="n">classification_count</span><span class="o">=</span><span class="s2">&quot;lc_ClassificationCount&quot;</span><span class="p">,</span>
    <span class="n">bit_binary</span><span class="o">=</span><span class="s2">&quot;lc_ClassificationBitBinary&quot;</span><span class="p">,</span>
    <span class="n">bit_decimal</span><span class="o">=</span><span class="s2">&quot;lc_ClassificationBitDecimal&quot;</span><span class="p">,</span>
    <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates the following flags:</span>
<span class="sd">    - `ClassificationCount`: The number of classifications per record.</span>
<span class="sd">    - `BitBinary`: A string that represents the presence of a classification in the North, South, East, and West directions. For example, if the entry is `1101`, that indicates that there is a valid classification for the North, South, and West Directions but no valid classifications for the East Direction.</span>
<span class="sd">    - `BitDecimal`: The number of photos that are pending approval per record.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    df : pd.DataFrame</span>
<span class="sd">        A land cover DataFrame</span>
<span class="sd">    north : str, default=&quot;lc_NorthClassifications&quot;</span>
<span class="sd">        The name of the column in the land cover DataFrame that contains the north classification.</span>
<span class="sd">    south : str, default=&quot;lc_SouthClassifications&quot;</span>
<span class="sd">        The name of the column in the land cover DataFrame that contains the south classification.</span>
<span class="sd">    east : str, default=&quot;lc_EastClassifications&quot;</span>
<span class="sd">        The name of the column in the land cover DataFrame that contains the east classification.</span>
<span class="sd">    west : str, default=&quot;lc_WestClassifications&quot;</span>
<span class="sd">        The name of the column in the land cover DataFrame that contains the west classification.</span>
<span class="sd">    classification_count : str, default=&quot;lc_ClassificationCount&quot;</span>
<span class="sd">        The name of the column that will store the ClassificationCount flag.</span>
<span class="sd">    bit_binary : str, default=&quot;lc_ClassificationBitBinary&quot;</span>
<span class="sd">        The name of the column that will store the BitBinary flag.</span>
<span class="sd">    bit_decimal : str, default=&quot;lc_ClassificationBitDecimal&quot;</span>
<span class="sd">        The name of the column that will store the BitDecimal flag.</span>
<span class="sd">    inplace : bool, default=False</span>
<span class="sd">        Whether to return a new DataFrame. If True then no DataFrame copy is not returned and the operation is performed in place.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pd.DataFrame or None</span>
<span class="sd">        A DataFrame with the classification bit flags. If `inplace=True` it returns None.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">classification_data</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="n">classification_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">classification_bit_mask</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">isna</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span> <span class="ow">or</span> <span class="n">entry</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">:</span>
                <span class="n">classification_bit_mask</span> <span class="o">+=</span> <span class="s2">&quot;0&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">classification_count</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">classification_bit_mask</span> <span class="o">+=</span> <span class="s2">&quot;1&quot;</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">classification_count</span><span class="p">,</span>
            <span class="n">classification_bit_mask</span><span class="p">,</span>
            <span class="nb">int</span><span class="p">(</span><span class="n">classification_bit_mask</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">get_classification_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">classification_data</span><span class="p">)</span>

    <span class="p">(</span>
        <span class="n">df</span><span class="p">[</span><span class="n">classification_count</span><span class="p">],</span>
        <span class="n">df</span><span class="p">[</span><span class="n">bit_binary</span><span class="p">],</span>
        <span class="n">df</span><span class="p">[</span><span class="n">bit_decimal</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">=</span> <span class="n">get_classification_data</span><span class="p">(</span>
        <span class="n">df</span><span class="p">[</span><span class="n">north</span><span class="p">],</span>
        <span class="n">df</span><span class="p">[</span><span class="n">south</span><span class="p">],</span>
        <span class="n">df</span><span class="p">[</span><span class="n">east</span><span class="p">],</span>
        <span class="n">df</span><span class="p">[</span><span class="n">west</span><span class="p">],</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">df</span>
</pre></div>

        </details>

            <div class="docstring"><p>Creates the following flags:</p>

<ul>
<li><code>ClassificationCount</code>: The number of classifications per record.</li>
<li><code>BitBinary</code>: A string that represents the presence of a classification in the North, South, East, and West directions. For example, if the entry is <code>1101</code>, that indicates that there is a valid classification for the North, South, and West Directions but no valid classifications for the East Direction.</li>
<li><code>BitDecimal</code>: The number of photos that are pending approval per record.</li>
</ul>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>df</strong> (pd.DataFrame):
A land cover DataFrame</li>
<li><strong>north</strong> (str, default="lc_NorthClassifications"):
The name of the column in the land cover DataFrame that contains the north classification.</li>
<li><strong>south</strong> (str, default="lc_SouthClassifications"):
The name of the column in the land cover DataFrame that contains the south classification.</li>
<li><strong>east</strong> (str, default="lc_EastClassifications"):
The name of the column in the land cover DataFrame that contains the east classification.</li>
<li><strong>west</strong> (str, default="lc_WestClassifications"):
The name of the column in the land cover DataFrame that contains the west classification.</li>
<li><strong>classification_count</strong> (str, default="lc_ClassificationCount"):
The name of the column that will store the ClassificationCount flag.</li>
<li><strong>bit_binary</strong> (str, default="lc_ClassificationBitBinary"):
The name of the column that will store the BitBinary flag.</li>
<li><strong>bit_decimal</strong> (str, default="lc_ClassificationBitDecimal"):
The name of the column that will store the BitDecimal flag.</li>
<li><strong>inplace</strong> (bool, default=False):
Whether to return a new DataFrame. If True then no DataFrame copy is not returned and the operation is performed in place.</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>pd.DataFrame or None</strong>: A DataFrame with the classification bit flags. If <code>inplace=True</code> it returns None.</li>
</ul>
</div>


                </section>
                <section id="completion_scores">
                            <div class="attr function"><a class="headerlink" href="#completion_scores">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">completion_scores</span><span class="signature">(
    df,
    photo_bit_binary=&#39;lc_PhotoBitBinary&#39;,
    classification_binary=&#39;lc_ClassificationBitBinary&#39;,
    sub_completeness=&#39;lc_SubCompletenessScore&#39;,
    completeness=&#39;lc_CumulativeCompletenessScore&#39;,
    inplace=False
)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">completion_scores</span><span class="p">(</span>
    <span class="n">df</span><span class="p">,</span>
    <span class="n">photo_bit_binary</span><span class="o">=</span><span class="s2">&quot;lc_PhotoBitBinary&quot;</span><span class="p">,</span>
    <span class="n">classification_binary</span><span class="o">=</span><span class="s2">&quot;lc_ClassificationBitBinary&quot;</span><span class="p">,</span>
    <span class="n">sub_completeness</span><span class="o">=</span><span class="s2">&quot;lc_SubCompletenessScore&quot;</span><span class="p">,</span>
    <span class="n">completeness</span><span class="o">=</span><span class="s2">&quot;lc_CumulativeCompletenessScore&quot;</span><span class="p">,</span>
    <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Adds the following completness score flags:</span>
<span class="sd">    - `SubCompletenessScore`: The percentage of valid landcover classifications and photos that are filled out.</span>
<span class="sd">    - `CumulativeCompletenessScore`: The percentage of non null values out of all the columns.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    df : pd.DataFrame</span>
<span class="sd">        A landcover DataFrame with the [`PhotoBitBinary`](#photo_bit_flags) and [`ClassificationBitBinary`](#classification_bit_flags) flags.</span>
<span class="sd">    photo_bit_binary : str, default=&quot;lc_PhotoBitBinary&quot;</span>
<span class="sd">        The name of the column that stores the PhotoBitBinary flag.</span>
<span class="sd">    classification_binary : str, default=&quot;lc_PhotoBitBinary&quot;</span>
<span class="sd">        The name of the column that stores the ClassificationBitBinary flag.</span>
<span class="sd">    sub_completeness : str, default=&quot;lc_PhotoBitBinary&quot;</span>
<span class="sd">        The name of the column that will store the generated SubCompletenessScore flag.</span>
<span class="sd">    completeness : str, default=&quot;lc_PhotoBitBinary&quot;</span>
<span class="sd">        The name of the column that will store the generated CompletenessScore flag.</span>
<span class="sd">    inplace : bool, default=False</span>
<span class="sd">        Whether to return a new DataFrame. If True then no DataFrame copy is not returned and the operation is performed in place.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pd.DataFrame or None</span>
<span class="sd">        A DataFrame with the completeness score flags. If `inplace=True` it returns None.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">sum_bit_mask</span><span class="p">(</span><span class="n">bit_mask</span><span class="o">=</span><span class="s2">&quot;0&quot;</span><span class="p">):</span>
        <span class="nb">sum</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">bit_mask</span><span class="p">:</span>
            <span class="nb">sum</span> <span class="o">+=</span> <span class="nb">int</span><span class="p">(</span><span class="n">char</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">sum</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">scores</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">scores</span><span class="p">[</span><span class="s2">&quot;sub_score&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># Cummulative Completion Score</span>
    <span class="n">scores</span><span class="p">[</span><span class="s2">&quot;cumulative_score&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
    <span class="c1"># Sub-Score</span>
    <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>
        <span class="n">bit_mask</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">photo_bit_binary</span><span class="p">][</span><span class="n">index</span><span class="p">]</span> <span class="o">+</span> <span class="n">df</span><span class="p">[</span><span class="n">classification_binary</span><span class="p">][</span><span class="n">index</span><span class="p">]</span>
        <span class="n">sub_score</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">sum_bit_mask</span><span class="p">(</span><span class="n">bit_mask</span><span class="o">=</span><span class="n">bit_mask</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">sub_score</span> <span class="o">/=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bit_mask</span><span class="p">)</span>
        <span class="n">scores</span><span class="p">[</span><span class="s2">&quot;sub_score&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sub_score</span><span class="p">)</span>

    <span class="n">df</span><span class="p">[</span><span class="n">sub_completeness</span><span class="p">],</span> <span class="n">df</span><span class="p">[</span><span class="n">completeness</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">scores</span><span class="p">[</span><span class="s2">&quot;sub_score&quot;</span><span class="p">],</span>
        <span class="n">scores</span><span class="p">[</span><span class="s2">&quot;cumulative_score&quot;</span><span class="p">],</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">df</span>
</pre></div>

        </details>

            <div class="docstring"><p>Adds the following completness score flags:</p>

<ul>
<li><code>SubCompletenessScore</code>: The percentage of valid landcover classifications and photos that are filled out.</li>
<li><code>CumulativeCompletenessScore</code>: The percentage of non null values out of all the columns.</li>
</ul>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>df</strong> (pd.DataFrame):
A landcover DataFrame with the <a href="#photo_bit_flags"><code>PhotoBitBinary</code></a> and <a href="#classification_bit_flags"><code>ClassificationBitBinary</code></a> flags.</li>
<li><strong>photo_bit_binary</strong> (str, default="lc_PhotoBitBinary"):
The name of the column that stores the PhotoBitBinary flag.</li>
<li><strong>classification_binary</strong> (str, default="lc_PhotoBitBinary"):
The name of the column that stores the ClassificationBitBinary flag.</li>
<li><strong>sub_completeness</strong> (str, default="lc_PhotoBitBinary"):
The name of the column that will store the generated SubCompletenessScore flag.</li>
<li><strong>completeness</strong> (str, default="lc_PhotoBitBinary"):
The name of the column that will store the generated CompletenessScore flag.</li>
<li><strong>inplace</strong> (bool, default=False):
Whether to return a new DataFrame. If True then no DataFrame copy is not returned and the operation is performed in place.</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>pd.DataFrame or None</strong>: A DataFrame with the completeness score flags. If <code>inplace=True</code> it returns None.</li>
</ul>
</div>


                </section>
                <section id="apply_cleanup">
                            <div class="attr function"><a class="headerlink" href="#apply_cleanup">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">apply_cleanup</span><span class="signature">(lc_df)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">apply_cleanup</span><span class="p">(</span><span class="n">lc_df</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Applies a full cleanup procedure to the landcover data.</span>
<span class="sd">    It follows the following steps:</span>
<span class="sd">    - Removes Homogenous Columns</span>
<span class="sd">    - Renames Latitude and Longitudes</span>
<span class="sd">    - Cleans the Column Naming</span>
<span class="sd">    - Unpacks landcover classifications</span>
<span class="sd">    - Rounds Columns</span>
<span class="sd">    - Standardizes Null Values</span>

<span class="sd">    This returns a copy</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lc_df : pd.DataFrame</span>
<span class="sd">        A DataFrame containing **raw** Landcover Data from the API.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pd.DataFrame</span>
<span class="sd">        A DataFrame containing the cleaned Landcover Data</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">lc_df</span> <span class="o">=</span> <span class="n">lc_df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">remove_homogenous_cols</span><span class="p">(</span><span class="n">lc_df</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">rename_latlon_cols</span><span class="p">(</span><span class="n">lc_df</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">cleanup_column_prefix</span><span class="p">(</span><span class="n">lc_df</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">lc_df</span> <span class="o">=</span> <span class="n">unpack_classifications</span><span class="p">(</span><span class="n">lc_df</span><span class="p">)</span>
    <span class="n">round_cols</span><span class="p">(</span><span class="n">lc_df</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">standardize_null_vals</span><span class="p">(</span><span class="n">lc_df</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">lc_df</span>
</pre></div>

        </details>

            <div class="docstring"><p>Applies a full cleanup procedure to the landcover data.
It follows the following steps:</p>

<ul>
<li>Removes Homogenous Columns</li>
<li>Renames Latitude and Longitudes</li>
<li>Cleans the Column Naming</li>
<li>Unpacks landcover classifications</li>
<li>Rounds Columns</li>
<li>Standardizes Null Values</li>
</ul>

<p>This returns a copy</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>lc_df</strong> (pd.DataFrame):
A DataFrame containing <strong>raw</strong> Landcover Data from the API.</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>pd.DataFrame</strong>: A DataFrame containing the cleaned Landcover Data</li>
</ul>
</div>


                </section>
                <section id="add_flags">
                            <div class="attr function"><a class="headerlink" href="#add_flags">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">add_flags</span><span class="signature">(lc_df)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">add_flags</span><span class="p">(</span><span class="n">lc_df</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Adds the following flags to the landcover data:</span>
<span class="sd">    - Photo Bit Flags</span>
<span class="sd">    - Classification Bit Flags</span>
<span class="sd">    - Completeness Score Flags</span>

<span class="sd">    Returns a copy of the DataFrame</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lc_df : pd.DataFrame</span>
<span class="sd">        A DataFrame containing cleaned up Landcover Data ideally from the [apply_cleanup](#apply_cleanup) method.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pd.DataFrame</span>
<span class="sd">        A DataFrame containing the Land Cover flags.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">lc_df</span> <span class="o">=</span> <span class="n">lc_df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">photo_bit_flags</span><span class="p">(</span><span class="n">lc_df</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">classification_bit_flags</span><span class="p">(</span><span class="n">lc_df</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">get_main_classifications</span><span class="p">(</span><span class="n">lc_df</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">completion_scores</span><span class="p">(</span><span class="n">lc_df</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">lc_df</span>
</pre></div>

        </details>

            <div class="docstring"><p>Adds the following flags to the landcover data:</p>

<ul>
<li>Photo Bit Flags</li>
<li>Classification Bit Flags</li>
<li>Completeness Score Flags</li>
</ul>

<p>Returns a copy of the DataFrame</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>lc_df</strong> (pd.DataFrame):
A DataFrame containing cleaned up Landcover Data ideally from the <a href="#apply_cleanup">apply_cleanup</a> method.</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>pd.DataFrame</strong>: A DataFrame containing the Land Cover flags.</li>
</ul>
</div>


                </section>
                <section id="direction_frequency">
                            <div class="attr function"><a class="headerlink" href="#direction_frequency">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">direction_frequency</span><span class="signature">(lc_df, direction_list, bit_binary, entry_type)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">direction_frequency</span><span class="p">(</span><span class="n">lc_df</span><span class="p">,</span> <span class="n">direction_list</span><span class="p">,</span> <span class="n">bit_binary</span><span class="p">,</span> <span class="n">entry_type</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plots the amount of a variable of interest for each direction.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lc_df : pd.DataFrame</span>
<span class="sd">        The DataFrame containing Land Cover Data.</span>
<span class="sd">    direction_list : list of str</span>
<span class="sd">        The column names of the different variables of interest for each direction.</span>
<span class="sd">    bit_binary: str</span>
<span class="sd">        The Bit Binary Flag associated with the variable of interest.</span>
<span class="sd">    entry_type: str</span>
<span class="sd">        The variable of interest (e.g. Photos or Classifications)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">direction_photos</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
    <span class="n">direction_photos</span><span class="p">[</span><span class="s2">&quot;category&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">direction_list</span>
    <span class="n">direction_counts</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">direction_photos</span><span class="p">))]</span>
    <span class="k">for</span> <span class="n">mask</span> <span class="ow">in</span> <span class="n">lc_df</span><span class="p">[</span><span class="n">bit_binary</span><span class="p">]:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">direction_counts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">int</span><span class="p">(</span><span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="n">direction_counts</span>
    <span class="n">direction_photos</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">math</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">direction_counts</span><span class="p">]</span>
    <span class="n">direction_photos</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
    <span class="n">title</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Land Cover -- </span><span class="si">{</span><span class="n">entry_type</span><span class="si">}</span><span class="s2"> Direction Frequency (Log Scale)&quot;</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Count (Log Scale)&quot;</span><span class="p">)</span>
    <span class="n">sns</span><span class="o">.</span><span class="n">barplot</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">direction_photos</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="s2">&quot;category&quot;</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="s2">&quot;count&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;lightblue&quot;</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Plots the amount of a variable of interest for each direction.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>lc_df</strong> (pd.DataFrame):
The DataFrame containing Land Cover Data.</li>
<li><strong>direction_list</strong> (list of str):
The column names of the different variables of interest for each direction.</li>
<li><strong>bit_binary</strong> (str):
The Bit Binary Flag associated with the variable of interest.</li>
<li><strong>entry_type</strong> (str):
The variable of interest (e.g. Photos or Classifications)</li>
</ul>
</div>


                </section>
                <section id="diagnostic_plots">
                            <div class="attr function"><a class="headerlink" href="#diagnostic_plots">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">diagnostic_plots</span><span class="signature">(
    lc_df,
    up_url=&#39;lc_UpwardPhotoUrl&#39;,
    down_url=&#39;lc_DownwardPhotoUrl&#39;,
    north_url=&#39;lc_NorthPhotoUrl&#39;,
    south_url=&#39;lc_SouthPhotoUrl&#39;,
    east_url=&#39;lc_EastPhotoUrl&#39;,
    west_url=&#39;lc_WestPhotoUrl&#39;,
    photo_bit=&#39;lc_PhotoBitBinary&#39;,
    north_classification=&#39;lc_NorthClassifications&#39;,
    south_classification=&#39;lc_SouthClassifications&#39;,
    east_classification=&#39;lc_EastClassifications&#39;,
    west_classification=&#39;lc_WestClassifications&#39;,
    classification_bit=&#39;lc_ClassificationBitBinary&#39;
)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">diagnostic_plots</span><span class="p">(</span>
    <span class="n">lc_df</span><span class="p">,</span>
    <span class="n">up_url</span><span class="o">=</span><span class="s2">&quot;lc_UpwardPhotoUrl&quot;</span><span class="p">,</span>
    <span class="n">down_url</span><span class="o">=</span><span class="s2">&quot;lc_DownwardPhotoUrl&quot;</span><span class="p">,</span>
    <span class="n">north_url</span><span class="o">=</span><span class="s2">&quot;lc_NorthPhotoUrl&quot;</span><span class="p">,</span>
    <span class="n">south_url</span><span class="o">=</span><span class="s2">&quot;lc_SouthPhotoUrl&quot;</span><span class="p">,</span>
    <span class="n">east_url</span><span class="o">=</span><span class="s2">&quot;lc_EastPhotoUrl&quot;</span><span class="p">,</span>
    <span class="n">west_url</span><span class="o">=</span><span class="s2">&quot;lc_WestPhotoUrl&quot;</span><span class="p">,</span>
    <span class="n">photo_bit</span><span class="o">=</span><span class="s2">&quot;lc_PhotoBitBinary&quot;</span><span class="p">,</span>
    <span class="n">north_classification</span><span class="o">=</span><span class="s2">&quot;lc_NorthClassifications&quot;</span><span class="p">,</span>
    <span class="n">south_classification</span><span class="o">=</span><span class="s2">&quot;lc_SouthClassifications&quot;</span><span class="p">,</span>
    <span class="n">east_classification</span><span class="o">=</span><span class="s2">&quot;lc_EastClassifications&quot;</span><span class="p">,</span>
    <span class="n">west_classification</span><span class="o">=</span><span class="s2">&quot;lc_WestClassifications&quot;</span><span class="p">,</span>
    <span class="n">classification_bit</span><span class="o">=</span><span class="s2">&quot;lc_ClassificationBitBinary&quot;</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates (but doesn&#39;t display) diagnostic plots to gain insight into the current data.</span>

<span class="sd">    Plots:</span>
<span class="sd">    - Valid Photo Count Distribution</span>
<span class="sd">    - Photo Distribution by direction</span>
<span class="sd">    - Classification Distribution by direction</span>
<span class="sd">    - Photo Status Distribution</span>
<span class="sd">    - Completeness Score Distribution</span>
<span class="sd">    - Subcompleteness Score Distribution</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lc_df : pd.DataFrame</span>
<span class="sd">        The DataFrame containing Flagged and Cleaned Land Cover Data.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">plot_freq_bar</span><span class="p">(</span>
        <span class="n">lc_df</span><span class="p">,</span> <span class="s2">&quot;Land Cover&quot;</span><span class="p">,</span> <span class="s2">&quot;lc_PhotoCount&quot;</span><span class="p">,</span> <span class="s2">&quot;Valid Photo Count&quot;</span><span class="p">,</span> <span class="n">log_scale</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">)</span>
    <span class="n">direction_frequency</span><span class="p">(</span>
        <span class="n">lc_df</span><span class="p">,</span>
        <span class="p">[</span><span class="n">up_url</span><span class="p">,</span> <span class="n">down_url</span><span class="p">,</span> <span class="n">north_url</span><span class="p">,</span> <span class="n">south_url</span><span class="p">,</span> <span class="n">east_url</span><span class="p">,</span> <span class="n">west_url</span><span class="p">],</span>
        <span class="n">photo_bit</span><span class="p">,</span>
        <span class="s2">&quot;Photo&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">direction_frequency</span><span class="p">(</span>
        <span class="n">lc_df</span><span class="p">,</span>
        <span class="p">[</span>
            <span class="n">north_classification</span><span class="p">,</span>
            <span class="n">south_classification</span><span class="p">,</span>
            <span class="n">east_classification</span><span class="p">,</span>
            <span class="n">west_classification</span><span class="p">,</span>
        <span class="p">],</span>
        <span class="n">classification_bit</span><span class="p">,</span>
        <span class="s2">&quot;Classification&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">multiple_bar_graph</span><span class="p">(</span>
        <span class="n">lc_df</span><span class="p">,</span>
        <span class="s2">&quot;Land Cover&quot;</span><span class="p">,</span>
        <span class="p">[</span><span class="s2">&quot;lc_PhotoCount&quot;</span><span class="p">,</span> <span class="s2">&quot;lc_RejectedCount&quot;</span><span class="p">,</span> <span class="s2">&quot;lc_EmptyCount&quot;</span><span class="p">],</span>
        <span class="s2">&quot;Photo Summary&quot;</span><span class="p">,</span>
        <span class="n">log_scale</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">completeness_histogram</span><span class="p">(</span>
        <span class="n">lc_df</span><span class="p">,</span> <span class="s2">&quot;Land Cover&quot;</span><span class="p">,</span> <span class="s2">&quot;lc_CumulativeCompletenessScore&quot;</span><span class="p">,</span> <span class="s2">&quot;Cumulative Completeness&quot;</span>
    <span class="p">)</span>
    <span class="n">completeness_histogram</span><span class="p">(</span>
        <span class="n">lc_df</span><span class="p">,</span> <span class="s2">&quot;Land Cover&quot;</span><span class="p">,</span> <span class="s2">&quot;lc_SubCompletenessScore&quot;</span><span class="p">,</span> <span class="s2">&quot;Sub Completeness&quot;</span>
    <span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Generates (but doesn't display) diagnostic plots to gain insight into the current data.</p>

<p>Plots:</p>

<ul>
<li>Valid Photo Count Distribution</li>
<li>Photo Distribution by direction</li>
<li>Classification Distribution by direction</li>
<li>Photo Status Distribution</li>
<li>Completeness Score Distribution</li>
<li>Subcompleteness Score Distribution</li>
</ul>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>lc_df</strong> (pd.DataFrame):
The DataFrame containing Flagged and Cleaned Land Cover Data.</li>
</ul>
</div>


                </section>
                <section id="qa_filter">
                            <div class="attr function"><a class="headerlink" href="#qa_filter">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">qa_filter</span><span class="signature">(
    lc_df,
    has_classification=False,
    has_photo=False,
    has_all_photos=False,
    has_all_classifications=False
)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">qa_filter</span><span class="p">(</span>
    <span class="n">lc_df</span><span class="p">,</span>
    <span class="n">has_classification</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">has_photo</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">has_all_photos</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">has_all_classifications</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Can filter a cleaned and flagged mosquito habitat mapper DataFrame based on the following criteria:</span>
<span class="sd">    - `Has Classification`: If the entry has atleast one direction classified</span>
<span class="sd">    - `Has Photo` : If the entry has atleast one photo taken</span>
<span class="sd">    - `Has All Photos` : If the entry has all photos taken (up, down, north, south, east, west)</span>
<span class="sd">    - `Has All Classifications` : If the entry has all directions classified</span>

<span class="sd">    Returns a copy of the DataFrame</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    has_classification : bool, default=False</span>
<span class="sd">        If True, only entries with atleast one classification will be included.</span>
<span class="sd">    has_photo : bool, default=False</span>
<span class="sd">        If True, only entries with atleast one photo will be included.</span>
<span class="sd">    has_all_photos : bool, default=False</span>
<span class="sd">        If True, only entries with all photos will be included.</span>
<span class="sd">    has_all_classifications : bool, default=False</span>
<span class="sd">        If True, only entries with all classifications will be included.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pd.DataFrame</span>
<span class="sd">        A DataFrame of the applied filters.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">has_classification</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">has_all_classifications</span><span class="p">:</span>
        <span class="n">lc_df</span> <span class="o">=</span> <span class="n">lc_df</span><span class="p">[</span><span class="n">lc_df</span><span class="p">[</span><span class="s2">&quot;lc_ClassificationBitDecimal&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">has_all_classifications</span><span class="p">:</span>
        <span class="n">lc_df</span> <span class="o">=</span> <span class="n">lc_df</span><span class="p">[</span><span class="n">lc_df</span><span class="p">[</span><span class="s2">&quot;lc_ClassificationBitDecimal&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">15</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">has_photo</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">has_all_photos</span><span class="p">:</span>
        <span class="n">lc_df</span> <span class="o">=</span> <span class="n">lc_df</span><span class="p">[</span><span class="n">lc_df</span><span class="p">[</span><span class="s2">&quot;lc_PhotoBitDecimal&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">has_all_photos</span><span class="p">:</span>
        <span class="n">lc_df</span> <span class="o">=</span> <span class="n">lc_df</span><span class="p">[</span><span class="n">lc_df</span><span class="p">[</span><span class="s2">&quot;lc_PhotoBitDecimal&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">63</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">lc_df</span>
</pre></div>

        </details>

            <div class="docstring"><p>Can filter a cleaned and flagged mosquito habitat mapper DataFrame based on the following criteria:</p>

<ul>
<li><code>Has Classification</code>: If the entry has atleast one direction classified</li>
<li><code>Has Photo</code> : If the entry has atleast one photo taken</li>
<li><code>Has All Photos</code> : If the entry has all photos taken (up, down, north, south, east, west)</li>
<li><code>Has All Classifications</code> : If the entry has all directions classified</li>
</ul>

<p>Returns a copy of the DataFrame</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>has_classification</strong> (bool, default=False):
If True, only entries with atleast one classification will be included.</li>
<li><strong>has_photo</strong> (bool, default=False):
If True, only entries with atleast one photo will be included.</li>
<li><strong>has_all_photos</strong> (bool, default=False):
If True, only entries with all photos will be included.</li>
<li><strong>has_all_classifications</strong> (bool, default=False):
If True, only entries with all classifications will be included.</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>pd.DataFrame</strong>: A DataFrame of the applied filters.</li>
</ul>
</div>


                </section>
                <section id="get_main_classifications">
                            <div class="attr function"><a class="headerlink" href="#get_main_classifications">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_main_classifications</span><span class="signature">(
    lc_df,
    north_classification=&#39;lc_NorthClassifications&#39;,
    east_classification=&#39;lc_EastClassifications&#39;,
    south_classification=&#39;lc_SouthClassifications&#39;,
    west_classification=&#39;lc_WestClassifications&#39;,
    north_primary=&#39;lc_NorthPrimary&#39;,
    north_secondary=&#39;lc_NorthSecondary&#39;,
    east_primary=&#39;lc_EastPrimary&#39;,
    east_secondary=&#39;lc_EastSecondary&#39;,
    south_primary=&#39;lc_SouthPrimary&#39;,
    south_secondary=&#39;lc_SouthSecondary&#39;,
    west_primary=&#39;lc_WestPrimary&#39;,
    west_secondary=&#39;lc_WestSecondary&#39;,
    primary_classification=&#39;lc_PrimaryClassification&#39;,
    secondary_classification=&#39;lc_SecondaryClassification&#39;,
    primary_percentage=&#39;lc_PrimaryPercentage&#39;,
    secondary_percentage=&#39;lc_SecondaryPercentage&#39;,
    inplace=False
)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">get_main_classifications</span><span class="p">(</span>
    <span class="n">lc_df</span><span class="p">,</span>
    <span class="n">north_classification</span><span class="o">=</span><span class="s2">&quot;lc_NorthClassifications&quot;</span><span class="p">,</span>
    <span class="n">east_classification</span><span class="o">=</span><span class="s2">&quot;lc_EastClassifications&quot;</span><span class="p">,</span>
    <span class="n">south_classification</span><span class="o">=</span><span class="s2">&quot;lc_SouthClassifications&quot;</span><span class="p">,</span>
    <span class="n">west_classification</span><span class="o">=</span><span class="s2">&quot;lc_WestClassifications&quot;</span><span class="p">,</span>
    <span class="n">north_primary</span><span class="o">=</span><span class="s2">&quot;lc_NorthPrimary&quot;</span><span class="p">,</span>
    <span class="n">north_secondary</span><span class="o">=</span><span class="s2">&quot;lc_NorthSecondary&quot;</span><span class="p">,</span>
    <span class="n">east_primary</span><span class="o">=</span><span class="s2">&quot;lc_EastPrimary&quot;</span><span class="p">,</span>
    <span class="n">east_secondary</span><span class="o">=</span><span class="s2">&quot;lc_EastSecondary&quot;</span><span class="p">,</span>
    <span class="n">south_primary</span><span class="o">=</span><span class="s2">&quot;lc_SouthPrimary&quot;</span><span class="p">,</span>
    <span class="n">south_secondary</span><span class="o">=</span><span class="s2">&quot;lc_SouthSecondary&quot;</span><span class="p">,</span>
    <span class="n">west_primary</span><span class="o">=</span><span class="s2">&quot;lc_WestPrimary&quot;</span><span class="p">,</span>
    <span class="n">west_secondary</span><span class="o">=</span><span class="s2">&quot;lc_WestSecondary&quot;</span><span class="p">,</span>
    <span class="n">primary_classification</span><span class="o">=</span><span class="s2">&quot;lc_PrimaryClassification&quot;</span><span class="p">,</span>
    <span class="n">secondary_classification</span><span class="o">=</span><span class="s2">&quot;lc_SecondaryClassification&quot;</span><span class="p">,</span>
    <span class="n">primary_percentage</span><span class="o">=</span><span class="s2">&quot;lc_PrimaryPercentage&quot;</span><span class="p">,</span>
    <span class="n">secondary_percentage</span><span class="o">=</span><span class="s2">&quot;lc_SecondaryPercentage&quot;</span><span class="p">,</span>
    <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span>
        <span class="n">lc_df</span> <span class="o">=</span> <span class="n">lc_df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">vectorized_rank</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">_rank_classifications</span><span class="p">)</span>
    <span class="p">(</span>
        <span class="n">lc_df</span><span class="p">[</span><span class="n">north_primary</span><span class="p">],</span>
        <span class="n">lc_df</span><span class="p">[</span><span class="n">north_secondary</span><span class="p">],</span>
        <span class="n">lc_df</span><span class="p">[</span><span class="n">east_primary</span><span class="p">],</span>
        <span class="n">lc_df</span><span class="p">[</span><span class="n">east_secondary</span><span class="p">],</span>
        <span class="n">lc_df</span><span class="p">[</span><span class="n">south_primary</span><span class="p">],</span>
        <span class="n">lc_df</span><span class="p">[</span><span class="n">south_secondary</span><span class="p">],</span>
        <span class="n">lc_df</span><span class="p">[</span><span class="n">west_primary</span><span class="p">],</span>
        <span class="n">lc_df</span><span class="p">[</span><span class="n">west_secondary</span><span class="p">],</span>
        <span class="n">lc_df</span><span class="p">[</span><span class="n">primary_classification</span><span class="p">],</span>
        <span class="n">lc_df</span><span class="p">[</span><span class="n">secondary_classification</span><span class="p">],</span>
        <span class="n">lc_df</span><span class="p">[</span><span class="n">primary_percentage</span><span class="p">],</span>
        <span class="n">lc_df</span><span class="p">[</span><span class="n">secondary_percentage</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">=</span> <span class="n">vectorized_rank</span><span class="p">(</span>
        <span class="n">lc_df</span><span class="p">[</span><span class="n">north_classification</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(),</span>
        <span class="n">lc_df</span><span class="p">[</span><span class="n">east_classification</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(),</span>
        <span class="n">lc_df</span><span class="p">[</span><span class="n">south_classification</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(),</span>
        <span class="n">lc_df</span><span class="p">[</span><span class="n">west_classification</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(),</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">lc_df</span>
</pre></div>

        </details>

    

                </section>
    </main>
            <script>/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();</script>
            <script>
                function escapeHTML(html) {
                    return document.createElement('div').appendChild(document.createTextNode(html)).parentNode.innerHTML;
                }

                const originalContent = document.querySelector("main.pdoc");
                let currentContent = originalContent;

                function setContent(innerHTML) {
                    let elem;
                    if (innerHTML) {
                        elem = document.createElement("main");
                        elem.classList.add("pdoc");
                        elem.innerHTML = innerHTML;
                    } else {
                        elem = originalContent;
                    }
                    if (currentContent !== elem) {
                        currentContent.replaceWith(elem);
                        currentContent = elem;
                    }
                }

                function getSearchTerm() {
                    return (new URL(window.location)).searchParams.get("search");
                }

                const searchBox = document.querySelector(".pdoc input[type=search]");
                searchBox.addEventListener("input", function () {
                    let url = new URL(window.location);
                    if (searchBox.value.trim()) {
                        url.hash = "";
                        url.searchParams.set("search", searchBox.value);
                    } else {
                        url.searchParams.delete("search");
                    }
                    history.replaceState("", "", url.toString());
                    onInput();
                });
                window.addEventListener("popstate", onInput);


                let searchIndex, searchErr;

                async function initialize() {
                    let docs;
                    try {
                        let resp = await fetch("../search.json");
                        docs = await resp.json();
                    } catch (e) {
                        searchErr = "Cannot fetch search index.";
                        throw e;
                    }

                    // Also split on html tags. this is a cheap heuristic, but good enough.
                    elasticlunr.tokenizer.setSeperator(/[\s\-.;&]+|<[^>]*>/);

                    if (docs._isPrebuiltIndex) {
                        console.info("using precompiled search index");
                        searchIndex = elasticlunr.Index.load(docs);
                    } else {
                        console.time("building search index");
                        searchIndex = elasticlunr(function () {
                            this.addField('qualname');
                            this.addField('fullname');
                            this.addField('doc');
                            this.setRef('fullname');
                        });
                        for (let doc of docs) {
                            searchIndex.addDoc(doc);
                        }
                        console.timeEnd("building search index");
                    }
                    onInput();

                    document.querySelector("nav.pdoc").addEventListener("click", e => {
                        if (e.target.hash) {
                            searchBox.value = "";
                            searchBox.dispatchEvent(new Event("input"));
                        }
                    });
                }

                function onInput() {
                    setContent((() => {
                        const search = getSearchTerm();
                        if (!search) {
                            return null
                        }
                        if (searchErr) {
                            return `<h3>Error: ${searchErr}</h3>`
                        }
                        if (!searchIndex) {
                            return "<h3>Searching...</h3>"
                        }

                        window.scrollTo({top: 0, left: 0, behavior: 'auto'});

                        const results = searchIndex.search(search, {
                            fields: {
                                qualname: {boost: 4},
                                fullname: {boost: 2},
                                doc: {boost: 1},
                            },
                            expand: true
                        });

                        let html;
                        if (results.length === 0) {
                            html = `No search results for '${escapeHTML(search)}'.`
                        } else {
                            html = `<h4>${results.length} search result${results.length > 1 ? "s" : ""} for '${escapeHTML(search)}'.</h4>`;
                        }
                        for (let result of results.slice(0, 10)) {
                            let doc = result.doc;
                            let url = `../${doc.modulename.replaceAll(".", "/")}.html`;
                            if (doc.qualname) {
                                url += `#${doc.qualname}`;
                            }

                            let heading;
                            switch (result.doc.type) {
                                case "function":
                                    heading = `<span class="def">${doc.funcdef}</span> <span class="name">${doc.fullname}</span><span class="signature">(${doc.parameters.join(", ")})</span>`;
                                    break;
                                case "class":
                                    heading = `<span class="def">class</span> <span class="name">${doc.fullname}</span>`;
                                    break;
                                default:
                                    heading = `<span class="name">${doc.fullname}</span>`;
                                    break;
                            }
                            html += `
                        <section class="search-result">
                        <a href="${url}" class="attr ${doc.type}">${heading}</a>
                        <div class="docstring">${doc.doc}</div>
                        </section>
                    `;

                        }
                        return html;
                    })());
                }

                if (getSearchTerm()) {
                    initialize();
                    searchBox.value = getSearchTerm();
                    onInput();
                } else {
                    searchBox.addEventListener("focus", initialize, {once: true});
                }

                searchBox.addEventListener("keydown", e => {
                    if (["ArrowDown", "ArrowUp", "Enter"].includes(e.key)) {
                        let focused = currentContent.querySelector(".search-result.focused");
                        if (!focused) {
                            currentContent.querySelector(".search-result").classList.add("focused");
                        } else if (
                            e.key === "ArrowDown"
                            && focused.nextElementSibling
                            && focused.nextElementSibling.classList.contains("search-result")
                        ) {
                            focused.classList.remove("focused");
                            focused.nextElementSibling.classList.add("focused");
                            focused.nextElementSibling.scrollIntoView({
                                behavior: "smooth",
                                block: "nearest",
                                inline: "nearest"
                            });
                        } else if (
                            e.key === "ArrowUp"
                            && focused.previousElementSibling
                            && focused.previousElementSibling.classList.contains("search-result")
                        ) {
                            focused.classList.remove("focused");
                            focused.previousElementSibling.classList.add("focused");
                            focused.previousElementSibling.scrollIntoView({
                                behavior: "smooth",
                                block: "nearest",
                                inline: "nearest"
                            });
                        } else if (
                            e.key === "Enter"
                        ) {
                            focused.querySelector("a").click();
                        }
                    }
                });
            </script>
</body>
</html>